import type { Express, Request, Response, NextFunction } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import bcrypt from "bcryptjs";
import { randomBytes } from "crypto";
import { defaultConfig } from "@shared/config";
import multer from "multer";
import path from "path";
import fs from "fs";
import { firebaseStorage, firebaseAuth, getAdminAuth, firestore } from "./firebase-admin";
import { sendDoctorApprovalEmail, sendAdminNotificationEmail, sendPatientApprovalEmail, sendWelcomeEmail } from "./email";

async function fireAutoMessageTriggers(applicationId: string, newStatus: string) {
  try {
    const app = await storage.getApplication(applicationId);
    if (!app || !app.packageId) return;

    const triggers = await storage.getAutoMessageTriggers(app.packageId);
    const matchingTriggers = triggers.filter(t => t.triggerStatus === newStatus);

    for (const trigger of matchingTriggers) {
      let recipientId: string | null = null;
      if (trigger.recipientType === "patient" && app.userId) {
        recipientId = app.userId;
      } else if (trigger.recipientType === "doctor") {
        recipientId = app.assignedReviewerId || app.assignedAgentId || null;
      }

      if (recipientId) {
        const messageBody = trigger.messageTemplate
          .replace("{{applicationId}}", applicationId)
          .replace("{{status}}", newStatus)
          .replace("{{packageName}}", (app as any).packageName || "your service");

        await storage.createMessage({
          senderId: "system",
          receiverId: recipientId,
          subject: `Application Update: ${newStatus}`,
          content: messageBody,
          isRead: false,
        } as any);

        await storage.createNotification({
          userId: recipientId,
          type: "auto_message",
          title: `Application Update`,
          message: messageBody.substring(0, 200),
          isRead: false,
        });
      }
    }
  } catch (error) {
    console.error("Error firing auto-message triggers:", error);
  }
}

async function autoGenerateDocument(applicationId: string, doctorId: string) {
  try {
    const app = await storage.getApplication(applicationId);
    if (!app) return;

    const doctorProfile = await storage.getDoctorProfileByUserId(doctorId);
    const patient = app.userId ? await storage.getUser(app.userId) : null;

    const docContent = {
      applicationId,
      packageName: (app as any).packageName || "Service Document",
      patientName: patient ? `${patient.firstName} ${patient.lastName}` : "Patient",
      patientEmail: patient?.email || "",
      doctorName: doctorProfile?.fullName || "Physician",
      doctorLicense: doctorProfile?.licenseNumber || "",
      doctorNPI: doctorProfile?.npiNumber || "",
      doctorDEA: doctorProfile?.deaNumber || "",
      generatedAt: new Date().toISOString(),
      status: "auto_generated",
      notes: app.level2Notes || app.level3Notes || "",
    };

    const document = await storage.createDocument({
      applicationId,
      userId: app.userId || "",
      name: `${(app as any).packageName || "Document"} - Auto Generated`,
      type: "auto_generated",
      status: "completed",
      fileUrl: "",
      metadata: docContent,
    } as any);

    return document;
  } catch (error) {
    console.error("Error auto-generating document:", error);
  }
}

const memoryUpload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 10 * 1024 * 1024 },
  fileFilter: (_req, file, cb) => {
    const allowed = ["image/jpeg", "image/png", "image/gif", "image/webp", "image/svg+xml"];
    if (allowed.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error("Only image files (JPEG, PNG, GIF, WebP, SVG) are allowed"));
    }
  },
});

const mediaUpload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 50 * 1024 * 1024 },
  fileFilter: (_req, file, cb) => {
    const allowed = [
      "image/jpeg", "image/png", "image/gif", "image/webp", "image/svg+xml",
      "video/mp4", "video/webm", "video/ogg",
    ];
    if (allowed.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error("Only image files (JPEG, PNG, GIF, WebP, SVG) and video files (MP4, WebM, OGG) are allowed"));
    }
  },
});

declare global {
  namespace Express {
    interface Request {
      user?: {
        id: string;
        username: string;
        firstName: string;
        lastName: string;
        userLevel: number;
        email: string;
        firebaseUid: string;
      };
    }
  }
}

const isAuthenticated = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const authHeader = req.headers.authorization;

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      res.status(401).json({ message: "Unauthorized - Firebase ID token required" });
      return;
    }

    const idToken = authHeader.split('Bearer ')[1];
    const decodedToken = await getAdminAuth().verifyIdToken(idToken);

    let user = await storage.getUserByFirebaseUid(decodedToken.uid);

    if (!user && decodedToken.email) {
      user = await storage.getUserByEmail(decodedToken.email);
      if (user) {
        await storage.updateUser(user.id, { firebaseUid: decodedToken.uid });
        user = (await storage.getUser(user.id))!;
      }
    }

    if (!user) {
      res.status(401).json({ message: "Unauthorized - User not found" });
      return;
    }

    req.user = {
      id: user.id,
      username: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      userLevel: user.userLevel,
      email: user.email,
      firebaseUid: decodedToken.uid,
    };
    return next();
  } catch (error) {
    console.error("Auth middleware error:", error);
    res.status(401).json({ message: "Unauthorized - Firebase authentication failed" });
  }
};

const requireAuth = isAuthenticated;

function requireLevel(minLevel: number) {
  return async (req: Request, res: Response, next: NextFunction) => {
    await isAuthenticated(req, res, () => {
      if (!req.user) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      if (req.user.userLevel < minLevel) {
        res.status(403).json({ message: "Forbidden - Insufficient permissions" });
        return;
      }
      next();
    });
  };
}

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {
  // ===========================================================================
  // ONE-TIME CONFIG MIGRATION - Update branding to Support Animal Registry
  // ===========================================================================
  try {
    const existingConfig = await storage.getSiteConfig();
    if (existingConfig && existingConfig.siteName && existingConfig.siteName !== defaultConfig.siteName) {
      await storage.updateSiteConfig({
        siteName: defaultConfig.siteName,
        tagline: defaultConfig.tagline,
        description: defaultConfig.description,
        heroTitle: defaultConfig.heroTitle,
        heroSubtitle: defaultConfig.heroSubtitle,
        heroButtonText: defaultConfig.heroButtonText,
        heroButtonLink: defaultConfig.heroButtonLink,
        heroSecondaryButtonText: defaultConfig.heroSecondaryButtonText,
        heroSecondaryButtonLink: defaultConfig.heroSecondaryButtonLink,
        footerQuickLinks: defaultConfig.footerQuickLinks,
        footerLegalLinks: defaultConfig.footerLegalLinks,
        level1Name: defaultConfig.levelNames.level1,
        level2Name: defaultConfig.levelNames.level2,
        level3Name: defaultConfig.levelNames.level3,
        level4Name: defaultConfig.levelNames.level4,
      } as any);
      console.log("[config] Migrated site config to new branding");
    }
  } catch (e: any) {
    console.log("[config] Config migration skipped:", e.message);
  }

  // ===========================================================================
  // FILE UPLOAD ROUTES (Firestore)
  // ===========================================================================

  app.post("/api/upload/gallery", requireAuth, requireLevel(4), (req, res, next) => {
    memoryUpload.single("image")(req, res, async (err) => {
      if (err instanceof multer.MulterError) {
        if (err.code === "LIMIT_FILE_SIZE") {
          res.status(400).json({ message: "File size must be under 10MB" });
          return;
        }
        res.status(400).json({ message: err.message });
        return;
      }
      if (err) {
        res.status(400).json({ message: err.message });
        return;
      }
      if (!req.file) {
        res.status(400).json({ message: "No file uploaded" });
        return;
      }

      try {
        const bucket = firebaseStorage.bucket();
        const uniqueSuffix = Date.now() + "-" + randomBytes(4).toString("hex");
        const ext = req.file.originalname ? "." + req.file.originalname.split(".").pop() : ".jpg";
        const fileName = `gallery/gallery-${uniqueSuffix}${ext}`;
        const file = bucket.file(fileName);

        await file.save(req.file.buffer, {
          metadata: { contentType: req.file.mimetype },
        });

        await file.makePublic();
        const url = `https://storage.googleapis.com/${bucket.name}/${fileName}`;
        res.json({ url });
      } catch (error: any) {
        console.error("Gallery upload error:", error);
        res.status(500).json({ message: "Failed to upload image" });
      }
    });
  });

  app.post("/api/upload/media", requireAuth, requireLevel(4), (req, res, next) => {
    mediaUpload.single("file")(req, res, async (err) => {
      if (err instanceof multer.MulterError) {
        if (err.code === "LIMIT_FILE_SIZE") {
          res.status(400).json({ message: "File size must be under 50MB" });
          return;
        }
        res.status(400).json({ message: err.message });
        return;
      }
      if (err) {
        res.status(400).json({ message: err.message });
        return;
      }
      if (!req.file) {
        res.status(400).json({ message: "No file uploaded" });
        return;
      }

      try {
        const allowedFolders = ["media", "hero", "about", "cta", "contact", "departments", "testimonials", "gallery"];
        const rawFolder = (req.body.folder || "media").replace(/[^a-zA-Z0-9_-]/g, "");
        const folder = allowedFolders.includes(rawFolder) ? rawFolder : "media";
        const bucket = firebaseStorage.bucket();
        const uniqueSuffix = Date.now() + "-" + randomBytes(4).toString("hex");
        const ext = req.file.originalname ? "." + req.file.originalname.split(".").pop() : ".jpg";
        const fileName = `${folder}/${folder}-${uniqueSuffix}${ext}`;
        const file = bucket.file(fileName);

        await file.save(req.file.buffer, {
          metadata: { contentType: req.file.mimetype },
        });

        await file.makePublic();
        const url = `https://storage.googleapis.com/${bucket.name}/${fileName}`;
        res.json({ url });
      } catch (error: any) {
        console.error("Media upload error:", error);
        res.status(500).json({ message: "Failed to upload file" });
      }
    });
  });

  // ===========================================================================
  // DEFAULT IMAGES (served from Firestore)
  // ===========================================================================

  const imageCache = new Map<string, { data: Buffer; contentType: string; etag: string }>();

  app.get("/api/default-images/:key", async (req, res) => {
    try {
      const { key } = req.params;
      if (!/^[a-zA-Z0-9_-]+$/.test(key)) {
        res.status(400).json({ message: "Invalid image key" });
        return;
      }

      const cached = imageCache.get(key);
      if (cached) {
        const ifNoneMatch = req.headers["if-none-match"];
        if (ifNoneMatch === cached.etag) {
          res.status(304).end();
          return;
        }
        res.set({
          "Content-Type": cached.contentType,
          "Content-Length": String(cached.data.length),
          "Cache-Control": "public, max-age=86400",
          "ETag": cached.etag,
        });
        res.send(cached.data);
        return;
      }

      const doc = await firestore.collection("defaultImages").doc(key).get();
      if (!doc.exists) {
        res.status(404).json({ message: "Image not found" });
        return;
      }

      const imgDoc = doc.data()!;
      const buffer = Buffer.from(imgDoc.data, "base64");
      const contentType = imgDoc.contentType || "image/jpeg";
      const etag = `"${key}-${imgDoc.size}"`;

      imageCache.set(key, { data: buffer, contentType, etag });

      res.set({
        "Content-Type": contentType,
        "Content-Length": String(buffer.length),
        "Cache-Control": "public, max-age=86400",
        "ETag": etag,
      });
      res.send(buffer);
    } catch (error: any) {
      console.error("Error serving default image:", error);
      res.status(500).json({ message: "Failed to load image" });
    }
  });

  // Serve uploaded media from Firestore
  app.get("/api/media/:key", async (req, res) => {
    try {
      const { key } = req.params;
      if (!/^[a-zA-Z0-9_-]+$/.test(key)) {
        res.status(400).json({ message: "Invalid media key" });
        return;
      }

      const cached = imageCache.get(`media-${key}`);
      if (cached) {
        const ifNoneMatch = req.headers["if-none-match"];
        if (ifNoneMatch === cached.etag) {
          res.status(304).end();
          return;
        }
        res.set({
          "Content-Type": cached.contentType,
          "Content-Length": String(cached.data.length),
          "Cache-Control": "public, max-age=86400",
          "ETag": cached.etag,
        });
        res.send(cached.data);
        return;
      }

      const doc = await firestore.collection("uploadedMedia").doc(key).get();
      if (!doc.exists) {
        res.status(404).json({ message: "Media not found" });
        return;
      }

      const mediaDoc = doc.data()!;
      const buffer = Buffer.from(mediaDoc.data, "base64");
      const contentType = mediaDoc.contentType || "application/octet-stream";
      const etag = `"media-${key}-${mediaDoc.size}"`;

      imageCache.set(`media-${key}`, { data: buffer, contentType, etag });

      res.set({
        "Content-Type": contentType,
        "Content-Length": String(buffer.length),
        "Cache-Control": "public, max-age=86400",
        "ETag": etag,
      });
      res.send(buffer);
    } catch (error: any) {
      console.error("Error serving uploaded media:", error);
      res.status(500).json({ message: "Failed to load media" });
    }
  });

  // ===========================================================================
  // AUTH ROUTES
  // ===========================================================================

  app.post("/api/auth/register", async (req, res) => {
    try {
      const {
        email, password, firstName, lastName, phone, referralCode, firebaseUid,
        middleName, dateOfBirth, address, city, state, zipCode,
        driverLicenseNumber, medicalCondition, ssn,
        hasMedicare, isVeteran,
        smsConsent, emailConsent, chargeUnderstanding, patientAuthorization
      } = req.body;

      if (!email || !password || !firstName || !lastName) {
        res.status(400).json({ message: "Missing required fields" });
        return;
      }

      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        res.status(400).json({ message: "Email already registered" });
        return;
      }

      const passwordHash = await bcrypt.hash(password, 10);

      const profileId = randomBytes(4).toString("hex").toUpperCase();
      const userReferralCode = randomBytes(4).toString("hex").toUpperCase();

      let referredByUserId: string | undefined;
      if (referralCode) {
        const referrer = await storage.getUserByReferralCode(referralCode);
        if (referrer) {
          referredByUserId = referrer.id;
        }
      }

      const registrationComplete = !!(firstName && lastName && phone && dateOfBirth && address && city && state && zipCode && smsConsent && emailConsent && chargeUnderstanding && patientAuthorization);

      const userData: any = {
        email,
        passwordHash,
        firstName,
        lastName,
        phone,
        firebaseUid: firebaseUid || null,
        userLevel: 1,
        profileId,
        referralCode: userReferralCode,
        referredByUserId,
        isActive: true,
        registrationComplete,
      };

      if (middleName) userData.middleName = middleName;
      if (dateOfBirth) userData.dateOfBirth = dateOfBirth;
      if (address) userData.address = address;
      if (city) userData.city = city;
      if (state) userData.state = state;
      if (zipCode) userData.zipCode = zipCode;
      if (driverLicenseNumber) userData.driverLicenseNumber = driverLicenseNumber;
      if (medicalCondition) userData.medicalCondition = medicalCondition;
      if (ssn) userData.ssn = ssn;
      if (hasMedicare !== undefined) userData.hasMedicare = hasMedicare;
      if (isVeteran !== undefined) userData.isVeteran = isVeteran;
      if (smsConsent !== undefined) userData.smsConsent = smsConsent;
      if (emailConsent !== undefined) userData.emailConsent = emailConsent;
      if (chargeUnderstanding !== undefined) userData.chargeUnderstanding = chargeUnderstanding;
      if (patientAuthorization !== undefined) userData.patientAuthorization = patientAuthorization;

      const user = await storage.createUser(userData);

      await storage.createActivityLog({
        userId: user.id,
        action: "user_registered",
        entityType: "user",
        entityId: user.id,
        details: { referredBy: referralCode || null },
      });

      res.json({
        user: {
          ...user,
          passwordHash: undefined,
        },
      });
    } catch (error: any) {
      console.error("Registration error:", error);
      res.status(500).json({ message: error.message || "Registration failed" });
    }
  });

  app.post("/api/auth/login", async (req, res) => {
    try {
      const { email, password } = req.body;

      if (!email || !password) {
        res.status(400).json({ message: "Email and password required" });
        return;
      }

      const user = await storage.getUserByEmail(email);
      if (!user || !user.passwordHash) {
        res.status(401).json({ message: "Invalid email or password" });
        return;
      }

      const isValid = await bcrypt.compare(password, user.passwordHash);
      if (!isValid) {
        res.status(401).json({ message: "Invalid email or password" });
        return;
      }

      if (!user.isActive) {
        res.status(401).json({ message: "Account is deactivated" });
        return;
      }

      // Log activity
      await storage.createActivityLog({
        userId: user.id,
        action: "user_login",
        entityType: "user",
        entityId: user.id,
      });

      let customToken: string | null = null;
      let firebaseUid = user.firebaseUid;

      try {
        const adminAuth = getAdminAuth();
        if (!firebaseUid) {
          try {
            const fbUser = await adminAuth.createUser({
              email: user.email,
              password,
              displayName: `${user.firstName} ${user.lastName}`,
            });
            firebaseUid = fbUser.uid;
            await storage.updateUser(user.id, { firebaseUid } as any);
          } catch (createErr: any) {
            if (createErr.code === 'auth/email-already-exists') {
              const fbUser = await adminAuth.getUserByEmail(user.email);
              firebaseUid = fbUser.uid;
              await storage.updateUser(user.id, { firebaseUid } as any);
            }
          }
        }
        if (firebaseUid) {
          customToken = await adminAuth.createCustomToken(firebaseUid);
        }
      } catch (fbErr: any) {
        console.error("Firebase custom token generation failed (non-blocking):", fbErr.message);
      }

      res.json({
        user: {
          ...user,
          passwordHash: undefined,
          password: undefined,
        },
        customToken,
      });
    } catch (error: any) {
      console.error("Login error:", error);
      res.status(500).json({ message: error.message || "Login failed" });
    }
  });

  app.post("/api/auth/firebase", async (req, res) => {
    try {
      const { idToken } = req.body;
      if (!idToken) {
        res.status(400).json({ message: "ID token required" });
        return;
      }

      const decodedToken = await firebaseAuth.verifyIdToken(idToken);
      const { uid, email, name, picture } = decodedToken;

      if (!email) {
        res.status(400).json({ message: "Email not available from Google account" });
        return;
      }

      let user = await storage.getUserByFirebaseUid(uid);

      if (!user) {
        user = await storage.getUserByEmail(email);
        if (user) {
          await storage.updateUser(user.id, { firebaseUid: uid, avatarUrl: picture || user.avatarUrl });
          user = (await storage.getUser(user.id))!;
        }
      }

      if (!user) {
        const nameParts = (name || email.split("@")[0]).split(" ");
        const firstName = nameParts[0] || "User";
        const lastName = nameParts.slice(1).join(" ") || "User";
        const profileId = randomBytes(4).toString("hex").toUpperCase();
        const userReferralCode = randomBytes(4).toString("hex").toUpperCase();

        user = await storage.createUser({
          email,
          firebaseUid: uid,
          firstName,
          lastName,
          passwordHash: null,
          userLevel: 1,
          profileId,
          referralCode: userReferralCode,
          avatarUrl: picture || null,
          isActive: true,
        });

        await storage.createActivityLog({
          userId: user.id,
          action: "user_registered",
          entityType: "user",
          entityId: user.id,
          details: { method: "google" } as any,
        });
      }

      if (!user.isActive) {
        res.status(401).json({ message: "Account is deactivated" });
        return;
      }

      await storage.createActivityLog({
        userId: user.id,
        action: "user_login",
        entityType: "user",
        entityId: user.id,
        details: { method: "google" } as any,
      });

      res.json({
        user: {
          ...user,
          passwordHash: undefined,
        },
      });
    } catch (error: any) {
      console.error("Firebase auth error:", error);
      res.status(401).json({ message: "Authentication failed" });
    }
  });

  app.post("/api/auth/logout", (_req, res) => {
    res.json({ message: "Logged out" });
  });

  app.get("/api/auth/me", async (req, res) => {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        res.status(401).json({ message: "Not authenticated - Firebase ID token required" });
        return;
      }

      const idToken = authHeader.split('Bearer ')[1];
      const decodedToken = await getAdminAuth().verifyIdToken(idToken);

      let user = await storage.getUserByFirebaseUid(decodedToken.uid);
      if (!user && decodedToken.email) {
        user = await storage.getUserByEmail(decodedToken.email);
        if (user) {
          await storage.updateUser(user.id, { firebaseUid: decodedToken.uid });
          user = (await storage.getUser(user.id))!;
        }
      }

      if (user) {
        res.json({ user: { ...user, passwordHash: undefined } });
        return;
      }

      res.status(401).json({ message: "Not authenticated - User not found" });
    } catch (error) {
      res.status(401).json({ message: "Not authenticated" });
    }
  });

  // ===========================================================================
  // PROFILE ROUTES (Self-service profile for applicants)
  // ===========================================================================

  app.get("/api/profile", requireAuth, async (req, res) => {
    try {
      const user = await storage.getUser(req.user!.id);
      if (!user) {
        res.status(404).json({ message: "User not found" });
        return;
      }
      res.json({ ...user, passwordHash: undefined });
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.put("/api/profile", requireAuth, async (req, res) => {
    try {
      const {
        firstName, middleName, lastName, phone, dateOfBirth,
        address, city, state, zipCode,
        driverLicenseNumber, medicalCondition, ssn,
        hasMedicare, isVeteran,
        smsConsent, emailConsent, chargeUnderstanding, patientAuthorization,
        registrationComplete, referralCode
      } = req.body;

      const updates: Record<string, any> = {};

      if (firstName !== undefined) updates.firstName = firstName;
      if (middleName !== undefined) updates.middleName = middleName;
      if (lastName !== undefined) updates.lastName = lastName;
      if (phone !== undefined) updates.phone = phone;
      if (dateOfBirth !== undefined) updates.dateOfBirth = dateOfBirth;
      if (address !== undefined) updates.address = address;
      if (city !== undefined) updates.city = city;
      if (state !== undefined) updates.state = state;
      if (zipCode !== undefined) updates.zipCode = zipCode;
      if (driverLicenseNumber !== undefined) updates.driverLicenseNumber = driverLicenseNumber;
      if (medicalCondition !== undefined) updates.medicalCondition = medicalCondition;
      if (ssn !== undefined) updates.ssn = ssn;
      if (hasMedicare !== undefined) updates.hasMedicare = hasMedicare;
      if (isVeteran !== undefined) updates.isVeteran = isVeteran;
      if (smsConsent !== undefined) updates.smsConsent = smsConsent;
      if (emailConsent !== undefined) updates.emailConsent = emailConsent;
      if (chargeUnderstanding !== undefined) updates.chargeUnderstanding = chargeUnderstanding;
      if (patientAuthorization !== undefined) updates.patientAuthorization = patientAuthorization;
      if (registrationComplete !== undefined) updates.registrationComplete = registrationComplete;
      if (referralCode !== undefined) updates.referralCode = referralCode;

      const user = await storage.updateUser(req.user!.id, updates as any);
      if (!user) {
        res.status(404).json({ message: "User not found" });
        return;
      }
      res.json({ ...user, passwordHash: undefined });
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // ===========================================================================
  // ADMIN SETTINGS ROUTES
  // ===========================================================================

  app.get("/api/admin/settings", requireAuth, requireLevel(3), async (req, res) => {
    try {
      const settings = await storage.getAdminSettings();
      res.json(settings || {});
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.put("/api/admin/settings", requireAuth, requireLevel(3), async (req, res) => {
    try {
      const settings = await storage.updateAdminSettings(req.body);
      res.json(settings);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // ===========================================================================
  // CONFIG ROUTES
  // ===========================================================================

  app.get("/api/config", async (req, res) => {
    try {
      const config = await storage.getSiteConfig();
      if (config) {
        res.json({
          siteName: config.siteName,
          tagline: config.tagline,
          description: config.description,
          logoUrl: config.logoUrl,
          faviconUrl: config.faviconUrl,
          primaryColor: config.primaryColor,
          secondaryColor: config.secondaryColor,
          accentColor: config.accentColor,
          heroTitle: config.heroTitle,
          heroSubtitle: config.heroSubtitle,
          heroBackgroundUrl: config.heroBackgroundUrl,
          heroMediaUrl: config.heroMediaUrl,
          heroButtonText: config.heroButtonText,
          heroButtonLink: config.heroButtonLink,
          heroSecondaryButtonText: config.heroSecondaryButtonText,
          heroSecondaryButtonLink: config.heroSecondaryButtonLink,
          footerQuickLinks: config.footerQuickLinks,
          footerLegalLinks: config.footerLegalLinks,
          footerText: config.footerText,
          contactEmail: config.contactEmail,
          contactPhone: config.contactPhone,
          address: config.address,
          aboutMediaUrl: config.aboutMediaUrl || "",
          ctaMediaUrl: config.ctaMediaUrl || "",
          contactMediaUrl: config.contactMediaUrl || "",
          departmentMediaUrls: config.departmentMediaUrls || [],
          testimonialMediaUrls: config.testimonialMediaUrls || [],
          galleryImages: config.galleryImages || [],
          levelNames: {
            level1: config.level1Name,
            level2: config.level2Name,
            level3: config.level3Name,
            level4: config.level4Name,
          },
          workflowSteps: defaultConfig.workflowSteps,
          features: defaultConfig.features,
        });
      } else {
        res.json(defaultConfig);
      }
    } catch (error) {
      res.json(defaultConfig);
    }
  });

  // ===========================================================================
  // PACKAGE ROUTES
  // ===========================================================================

  app.get("/api/packages", async (req, res) => {
    try {
      const packages = await storage.getActivePackages();
      res.json(packages);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.get("/api/packages/:id", async (req, res) => {
    try {
      const pkg = await storage.getPackage(req.params.id);
      if (!pkg) {
        res.status(404).json({ message: "Package not found" });
        return;
      }
      res.json(pkg);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // ===========================================================================
  // APPLICATION ROUTES (Authenticated)
  // ===========================================================================

  app.get("/api/applications", requireAuth, async (req, res) => {
    try {
      const applications = await storage.getApplicationsByUser(req.user!.id);
      res.json(applications);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.get("/api/applications/:id", requireAuth, async (req, res) => {
    try {
      const application = await storage.getApplication(req.params.id as string);
      if (!application) {
        res.status(404).json({ message: "Application not found" });
        return;
      }
      // Check ownership or admin access
      if (application.userId !== req.user!.id && req.user!.userLevel < 3) {
        res.status(403).json({ message: "Forbidden" });
        return;
      }
      res.json(application);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.post("/api/applications", requireAuth, async (req, res) => {
    try {
      const { packageId, formData, paymentStatus: reqPaymentStatus, autoSendToDoctor } = req.body;

      const pkg = await storage.getPackage(packageId);
      if (!pkg) {
        res.status(400).json({ message: "Invalid package" });
        return;
      }

      const workflowSteps = (pkg.workflowSteps as string[]) || defaultConfig.workflowSteps;

      const application = await storage.createApplication({
        userId: req.user!.id,
        packageId,
        currentStep: 1,
        totalSteps: workflowSteps.length,
        status: "pending",
        formData: formData || {},
        paymentStatus: reqPaymentStatus || "unpaid",
        paymentAmount: pkg.price,
      });

      for (let i = 0; i < workflowSteps.length; i++) {
        await storage.createApplicationStep({
          applicationId: application.id,
          stepNumber: i + 1,
          name: workflowSteps[i],
          status: i === 0 ? "in-progress" : "pending",
        });
      }

      if (reqPaymentStatus === "paid" || autoSendToDoctor) {
        try {
          const doctor = await storage.getNextDoctorForAssignment();
          if (doctor) {
            const token = randomBytes(32).toString("hex");
            const expiresAt = new Date();
            expiresAt.setDate(expiresAt.getDate() + 7);

            await storage.createDoctorReviewToken({
              applicationId: application.id,
              doctorId: doctor.userId || doctor.id,
              token,
              status: "pending",
              expiresAt,
            });

            await storage.updateApplication(application.id, {
              status: "doctor_review",
              assignedReviewerId: doctor.userId || doctor.id,
            });

            const patient = req.user!;
            const doctorUser = await storage.getUser(doctor.userId || doctor.id);
            const protocol = process.env.NODE_ENV === "production" ? "https" : "https";
            const host = req.get("host") || "localhost:5000";
            const reviewUrl = `${protocol}://${host}/review/${token}`;
            const patientName = `${patient.firstName} ${patient.lastName}`;

            if (doctorUser?.email) {
              sendDoctorApprovalEmail({
                doctorEmail: doctorUser.email,
                doctorName: doctorUser.lastName || doctor.fullName || "Doctor",
                patientName,
                patientEmail: patient.email,
                packageName: pkg.name,
                formData: formData || {},
                reviewUrl,
                applicationId: application.id,
              }).catch(err => console.error("Auto doctor email error:", err));
            }

            const adminSettings = await storage.getAdminSettings();
            const notificationEmail = adminSettings?.notificationEmail;
            if (notificationEmail) {
              sendAdminNotificationEmail({
                adminEmail: notificationEmail,
                doctorName: doctorUser?.lastName || doctor.fullName || "Doctor",
                patientName,
                patientEmail: patient.email,
                packageName: pkg.name,
                formData: formData || {},
                reviewUrl,
                applicationId: application.id,
              }).catch(err => console.error("Auto admin email error:", err));
            }

            fireAutoMessageTriggers(application.id, "doctor_review");
            application.status = "doctor_review" as any;
          }
        } catch (autoErr) {
          console.error("Auto send-to-doctor failed (non-blocking):", autoErr);
        }
      }

      res.json(application);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // ===========================================================================
  // DOCUMENTS ROUTES (User-facing)
  // ===========================================================================

  app.get("/api/documents", requireAuth, async (req, res) => {
    try {
      const documents = await storage.getDocumentsByUser(req.user!.id);
      res.json(documents);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // ===========================================================================
  // PAYMENTS ROUTES (User-facing)
  // ===========================================================================

  app.get("/api/payments", requireAuth, async (req, res) => {
    try {
      const payments = await storage.getPaymentsByUser(req.user!.id);
      res.json(payments);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // ===========================================================================
  // MESSAGES ROUTES
  // ===========================================================================

  app.get("/api/messages", requireAuth, async (req, res) => {
    try {
      const messages = await storage.getMessagesForUser(req.user!.id);
      res.json(messages);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.post("/api/messages", requireAuth, async (req, res) => {
    try {
      const { receiverId, subject, content, applicationId } = req.body;
      if (!receiverId || !content) {
        res.status(400).json({ message: "Receiver and content are required" });
        return;
      }
      const message = await storage.createMessage({
        senderId: req.user!.id,
        receiverId,
        subject: subject || null,
        content,
        applicationId: applicationId || null,
        isRead: false,
      });
      res.status(201).json(message);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.patch("/api/messages/:id/read", requireAuth, async (req, res) => {
    try {
      const msg = await storage.getMessage(req.params.id as string);
      if (!msg) {
        res.status(404).json({ message: "Message not found" });
        return;
      }
      if (msg.receiverId !== req.user!.id) {
        res.status(403).json({ message: "Not authorized" });
        return;
      }
      const message = await storage.markMessageAsRead(req.params.id as string);
      res.json(message);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // ===========================================================================
  // NOTIFICATIONS ROUTES
  // ===========================================================================

  app.get("/api/notifications", requireAuth, async (req, res) => {
    try {
      const notifications = await storage.getNotificationsByUser(req.user!.id);
      res.json(notifications);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.get("/api/notifications/unread", requireAuth, async (req, res) => {
    try {
      const notifications = await storage.getUnreadNotifications(req.user!.id);
      res.json(notifications);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.patch("/api/notifications/:id/read", requireAuth, async (req, res) => {
    try {
      const existing = await storage.getNotification(req.params.id as string);
      if (!existing) {
        res.status(404).json({ message: "Notification not found" });
        return;
      }
      if (existing.userId !== req.user!.id) {
        res.status(403).json({ message: "Not authorized" });
        return;
      }
      const notification = await storage.markNotificationAsRead(req.params.id as string);
      res.json(notification);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.post("/api/notifications/read-all", requireAuth, async (req, res) => {
    try {
      await storage.markAllNotificationsAsRead(req.user!.id);
      res.json({ success: true });
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // ===========================================================================
  // DOCTOR ASSIGNMENT & REVIEW ROUTES
  // ===========================================================================

  app.get("/api/doctors", requireAuth, requireLevel(3), async (req, res) => {
    try {
      const doctors = await storage.getActiveDoctors();
      const doctorsWithUsers = await Promise.all(
        doctors.map(async (doc) => {
          const user = doc.userId ? await storage.getUser(doc.userId) : null;
          return {
            ...doc,
            firstName: user?.firstName,
            lastName: user?.lastName,
            email: user?.email,
          };
        })
      );
      res.json(doctorsWithUsers);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.get("/api/doctors/stats", requireAuth, requireLevel(2), async (req, res) => {
    try {
      const doctorId = req.query.doctorId as string || req.user!.id;
      const tokens = await storage.getDoctorReviewTokensByDoctor(doctorId);
      const approved = tokens.filter(t => t.status === "approved").length;
      const denied = tokens.filter(t => t.status === "denied").length;
      const pending = tokens.filter(t => t.status === "pending").length;
      res.json({ total: tokens.length, approved, denied, pending, tokens });
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.post("/api/admin/applications/:id/send-to-doctor", requireAuth, requireLevel(3), async (req, res) => {
    try {
      const applicationId = req.params.id as string;
      const { doctorId: manualDoctorId } = req.body;

      const application = await storage.getApplication(applicationId);
      if (!application) {
        res.status(404).json({ message: "Application not found" });
        return;
      }

      let doctor;
      if (manualDoctorId) {
        doctor = await storage.getDoctorProfile(manualDoctorId);
        if (!doctor) {
          const allDoctors = await storage.getActiveDoctors();
          doctor = allDoctors.find(d => d.userId === manualDoctorId);
        }
      } else {
        doctor = await storage.getNextDoctorForAssignment();
      }

      if (!doctor) {
        res.status(400).json({ message: "No active doctors available for assignment" });
        return;
      }

      const token = randomBytes(32).toString("hex");
      const expiresAt = new Date();
      expiresAt.setDate(expiresAt.getDate() + 7);

      const reviewToken = await storage.createDoctorReviewToken({
        applicationId,
        doctorId: doctor.userId || doctor.id,
        token,
        status: "pending",
        expiresAt,
      });

      await storage.updateApplication(applicationId, {
        status: "doctor_review",
        assignedReviewerId: doctor.userId || doctor.id,
      });

      const patient = application.userId ? await storage.getUser(application.userId) : null;
      const pkg = application.packageId ? await storage.getPackage(application.packageId) : null;
      const doctorUser = await storage.getUser(doctor.userId || doctor.id);

      const protocol = process.env.NODE_ENV === "production" ? "https" : "https";
      const host = req.get("host") || "localhost:5000";
      const reviewUrl = `${protocol}://${host}/review/${token}`;

      await storage.createNotification({
        userId: req.user!.id,
        type: "doctor_assignment",
        title: "Application Sent to Doctor",
        message: `Application for ${patient?.firstName || "Patient"} ${patient?.lastName || ""} sent to Dr. ${doctorUser?.lastName || doctor.fullName || "Doctor"}. Review link: ${reviewUrl}`,
        isRead: false,
        actionUrl: reviewUrl,
      });

      if (doctorUser) {
        await storage.createNotification({
          userId: doctorUser.id,
          type: "review_assigned",
          title: "New Patient Review Assigned",
          message: `You have been assigned to review ${patient?.firstName || "a patient"}'s application for ${pkg?.name || "a service"}.`,
          isRead: false,
        });
      }

      fireAutoMessageTriggers(applicationId, "doctor_review");

      const patientName = patient ? `${patient.firstName} ${patient.lastName}` : "Patient";
      if (doctorUser?.email) {
        sendDoctorApprovalEmail({
          doctorEmail: doctorUser.email,
          doctorName: doctorUser.lastName || doctor.fullName || "Doctor",
          patientName,
          patientEmail: patient?.email || "",
          packageName: pkg?.name || "Service",
          formData: (application.formData as Record<string, any>) || {},
          reviewUrl,
          applicationId,
        }).catch(err => console.error("Send-to-doctor email error:", err));
      }

      const adminSettings = await storage.getAdminSettings();
      const notificationEmail = adminSettings?.notificationEmail;
      if (notificationEmail) {
        sendAdminNotificationEmail({
          adminEmail: notificationEmail,
          doctorName: doctorUser?.lastName || doctor.fullName || "Doctor",
          patientName,
          patientEmail: patient?.email || "",
          packageName: pkg?.name || "Service",
          formData: (application.formData as Record<string, any>) || {},
          reviewUrl,
          applicationId,
        }).catch(err => console.error("Admin notification email error:", err));
      }

      await storage.createActivityLog({
        userId: req.user!.id,
        action: "application_sent_to_doctor",
        entityType: "application",
        entityId: applicationId,
        details: {
          doctorId: doctor.userId || doctor.id,
          doctorName: doctorUser ? `${doctorUser.firstName} ${doctorUser.lastName}` : doctor.fullName,
          reviewUrl,
          tokenId: reviewToken.id,
        } as any,
      });

      res.json({
        message: "Application sent to doctor for review",
        reviewUrl,
        token: reviewToken,
        doctor: {
          id: doctor.userId || doctor.id,
          name: doctorUser ? `${doctorUser.firstName} ${doctorUser.lastName}` : doctor.fullName,
        },
      });
    } catch (error: any) {
      console.error("Send to doctor error:", error);
      res.status(500).json({ message: error.message });
    }
  });

  app.get("/api/review/:token", async (req, res) => {
    try {
      const tokenRecord = await storage.getDoctorReviewTokenByToken(req.params.token);
      if (!tokenRecord) {
        res.status(404).json({ message: "Review link not found or invalid" });
        return;
      }

      if (tokenRecord.status !== "pending") {
        res.status(410).json({ message: "This review has already been completed", status: tokenRecord.status });
        return;
      }

      if (new Date() > new Date(tokenRecord.expiresAt)) {
        await storage.updateDoctorReviewToken(tokenRecord.id, { status: "expired" } as any);
        res.status(410).json({ message: "This review link has expired" });
        return;
      }

      const application = await storage.getApplication(tokenRecord.applicationId);
      if (!application) {
        res.status(404).json({ message: "Application not found" });
        return;
      }

      const patient = application.userId ? await storage.getUser(application.userId) : null;
      const pkg = application.packageId ? await storage.getPackage(application.packageId) : null;
      const doctorUser = await storage.getUser(tokenRecord.doctorId);
      const doctorProfile = await storage.getDoctorProfileByUserId(tokenRecord.doctorId);

      res.json({
        tokenId: tokenRecord.id,
        status: tokenRecord.status,
        expiresAt: tokenRecord.expiresAt,
        patient: patient ? {
          firstName: patient.firstName,
          lastName: patient.lastName,
          email: patient.email,
          phone: patient.phone,
          dateOfBirth: patient.dateOfBirth,
          address: patient.address,
          city: patient.city,
          state: patient.state,
          zipCode: patient.zipCode,
        } : null,
        application: {
          id: application.id,
          status: application.status,
          formData: application.formData,
          createdAt: application.createdAt,
        },
        package: pkg ? {
          name: pkg.name,
          description: pkg.description,
        } : null,
        doctor: doctorUser ? {
          firstName: doctorUser.firstName,
          lastName: doctorUser.lastName,
        } : null,
        doctorProfile: doctorProfile ? {
          fullName: doctorProfile.fullName,
          licenseNumber: doctorProfile.licenseNumber,
          specialty: doctorProfile.specialty,
          state: doctorProfile.state,
        } : null,
      });
    } catch (error: any) {
      console.error("Review token lookup error:", error);
      res.status(500).json({ message: "Failed to load review" });
    }
  });

  app.post("/api/review/:token/decision", async (req, res) => {
    try {
      const { decision, notes } = req.body;
      if (!decision || !["approved", "denied"].includes(decision)) {
        res.status(400).json({ message: "Decision must be 'approved' or 'denied'" });
        return;
      }

      const tokenRecord = await storage.getDoctorReviewTokenByToken(req.params.token);
      if (!tokenRecord) {
        res.status(404).json({ message: "Review link not found" });
        return;
      }

      if (tokenRecord.status !== "pending") {
        res.status(410).json({ message: "This review has already been completed" });
        return;
      }

      if (new Date() > new Date(tokenRecord.expiresAt)) {
        await storage.updateDoctorReviewToken(tokenRecord.id, { status: "expired" } as any);
        res.status(410).json({ message: "This review link has expired" });
        return;
      }

      await storage.updateDoctorReviewToken(tokenRecord.id, {
        status: decision,
        usedAt: new Date(),
        doctorNotes: notes || null,
      } as any);

      const application = await storage.getApplication(tokenRecord.applicationId);

      if (decision === "approved") {
        await storage.updateApplication(tokenRecord.applicationId, {
          status: "doctor_approved",
          level2Notes: notes,
          level2ApprovedAt: new Date(),
          level2ApprovedBy: tokenRecord.doctorId,
          assignedReviewerId: tokenRecord.doctorId,
        });

        await autoGenerateDocument(tokenRecord.applicationId, tokenRecord.doctorId);
        fireAutoMessageTriggers(tokenRecord.applicationId, "doctor_approved");

        if (application?.userId) {
          await storage.createNotification({
            userId: application.userId,
            type: "application_approved",
            title: "Application Approved",
            message: "Your application has been approved by the reviewing doctor. Your documents are being prepared.",
            isRead: false,
          });

          const patient = await storage.getUser(application.userId);
          if (patient?.email) {
            const pkg = application.packageId ? await storage.getPackage(application.packageId) : null;
            const protocol = process.env.NODE_ENV === "production" ? "https" : "https";
            const host = req.get?.("host") || process.env.APP_HOST || "pawcredentials.com";
            const dashboardUrl = `${protocol}://${host}/dashboard/applicant`;
            sendPatientApprovalEmail({
              patientEmail: patient.email,
              patientName: `${patient.firstName} ${patient.lastName}`,
              packageName: pkg?.name || "ESA Letter",
              applicationId: tokenRecord.applicationId,
              dashboardUrl,
            }).catch(err => console.error("Patient approval email error:", err));
          }
        }
      } else {
        await storage.updateApplication(tokenRecord.applicationId, {
          status: "doctor_denied",
          level2Notes: notes,
          rejectedAt: new Date(),
          rejectedBy: tokenRecord.doctorId,
          rejectionReason: notes,
        });

        fireAutoMessageTriggers(tokenRecord.applicationId, "doctor_denied");

        if (application?.userId) {
          await storage.createNotification({
            userId: application.userId,
            type: "application_denied",
            title: "Application Not Approved",
            message: notes ? `Your application was not approved. Reason: ${notes}` : "Your application was not approved at this time.",
            isRead: false,
          });
        }
      }

      await storage.createActivityLog({
        userId: tokenRecord.doctorId,
        action: `doctor_${decision}`,
        entityType: "application",
        entityId: tokenRecord.applicationId,
        details: { notes, tokenId: tokenRecord.id } as any,
      });

      res.json({ message: `Application ${decision} successfully`, decision });
    } catch (error: any) {
      console.error("Doctor decision error:", error);
      res.status(500).json({ message: "Failed to submit decision" });
    }
  });

  app.get("/api/review-tokens", requireAuth, requireLevel(3), async (req, res) => {
    try {
      const applicationId = req.query.applicationId as string;
      if (applicationId) {
        const tokens = await storage.getDoctorReviewTokensByApplication(applicationId);
        res.json(tokens);
      } else {
        res.status(400).json({ message: "applicationId query parameter required" });
      }
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // ===========================================================================
  // COMMISSION ROUTES
  // ===========================================================================

  app.get("/api/commissions", requireAuth, async (req, res) => {
    try {
      if (req.user!.userLevel >= 3) {
        const commissions = await storage.getAllCommissions();
        res.json(commissions);
      } else {
        const commissions = await storage.getCommissionsByAgent(req.user!.id);
        res.json(commissions);
      }
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // ===========================================================================
  // LEVEL 3 (AGENT) WORK QUEUE ROUTES
  // ===========================================================================

  // Get Level 3 work queue - applications ready for agent work
  app.get("/api/agent/work-queue", requireAuth, requireLevel(2), async (req, res) => {
    try {
      const applications = await storage.getApplicationsByStatus("level3_work");
      res.json(applications);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // Get Level 3 work queue stats
  app.get("/api/agent/work-queue/stats", requireAuth, requireLevel(2), async (req, res) => {
    try {
      const allApps = await storage.getApplicationsByStatus("level3_work");
      const waiting = allApps.filter(a => !a.assignedAgentId).length;
      const inProgress = allApps.filter(a => a.assignedAgentId === req.user!.id).length;
      
      const pendingVerification = await storage.getApplicationsByStatus("level4_verification");
      const completedApps = await storage.getApplicationsByStatus("completed");
      const allCompleted = [...pendingVerification, ...completedApps];
      const completedTotal = allCompleted.filter(a => a.level3CompletedBy === req.user!.id).length;
      
      res.json({ waiting, inProgress, completedTotal });
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // Get Level 3's completed applications (for their completed tab)
  app.get("/api/agent/my-completed", requireAuth, requireLevel(2), async (req, res) => {
    try {
      // Get all apps completed by this agent (pending verification + fully completed)
      const pendingVerification = await storage.getApplicationsByStatus("level4_verification");
      const completedApps = await storage.getApplicationsByStatus("completed");
      const allCompleted = [...pendingVerification, ...completedApps];
      const myCompleted = allCompleted.filter(a => a.level3CompletedBy === req.user!.id);
      res.json(myCompleted);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // Level 3: Claim an application
  app.post("/api/agent/work-queue/:id/claim", requireAuth, requireLevel(2), async (req, res) => {
    try {
      const app = await storage.getApplication(req.params.id as string);
      if (!app) {
        res.status(404).json({ message: "Application not found" });
        return;
      }
      if (app.status !== "level3_work") {
        res.status(400).json({ message: "Application is not in Level 3 work queue" });
        return;
      }
      if (app.assignedAgentId) {
        res.status(400).json({ message: "Application already claimed by another agent" });
        return;
      }
      const updated = await storage.updateApplication(req.params.id as string, {
        assignedAgentId: req.user!.id,
      });
      res.json(updated);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // Level 3: Complete work and send to Level 4 for verification
  app.post("/api/agent/work-queue/:id/complete", requireAuth, requireLevel(2), async (req, res) => {
    try {
      const { notes } = req.body;
      const app = await storage.getApplication(req.params.id as string);
      if (!app) {
        res.status(404).json({ message: "Application not found" });
        return;
      }
      if (app.assignedAgentId !== req.user!.id) {
        res.status(403).json({ message: "This application is not assigned to you" });
        return;
      }
      const updated = await storage.updateApplication(req.params.id as string, {
        status: "level4_verification",
        currentLevel: 3,
        level3Notes: notes,
        level3CompletedAt: new Date(),
        level3CompletedBy: req.user!.id,
      });
      await autoGenerateDocument(req.params.id as string, req.user!.id);
      fireAutoMessageTriggers(req.params.id as string, "level3_complete");
      res.json(updated);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // ===========================================================================
  // LEVEL 4 (ADMIN) VERIFICATION QUEUE ROUTES
  // ===========================================================================

  // Get Level 4 verification queue
  app.get("/api/admin/verification-queue", requireAuth, requireLevel(3), async (req, res) => {
    try {
      const applications = await storage.getApplicationsByStatus("level4_verification");
      res.json(applications);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // Get Level 4 verification queue stats
  app.get("/api/admin/verification-queue/stats", requireAuth, requireLevel(3), async (req, res) => {
    try {
      const pendingApps = await storage.getApplicationsByStatus("level4_verification");
      const pending = pendingApps.length;
      
      // Get today's verifications
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const completedApps = await storage.getApplicationsByStatus("completed");
      const completedToday = completedApps.filter(a => 
        a.level4VerifiedBy === req.user!.id && 
        a.level4VerifiedAt && new Date(a.level4VerifiedAt) >= today
      ).length;
      
      res.json({ pending, completedToday });
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // Level 4: Verify and complete an application
  app.post("/api/admin/verification-queue/:id/verify", requireAuth, requireLevel(3), async (req, res) => {
    try {
      const { notes, approved } = req.body;
      const app = await storage.getApplication(req.params.id as string);
      if (!app) {
        res.status(404).json({ message: "Application not found" });
        return;
      }
      if (app.status !== "level4_verification") {
        res.status(400).json({ message: "Application is not pending verification" });
        return;
      }
      
      if (approved) {
        const updated = await storage.updateApplication(req.params.id as string, {
          status: "completed",
          currentLevel: 4,
          level4Notes: notes,
          level4VerifiedAt: new Date(),
          level4VerifiedBy: req.user!.id,
          approvedAt: new Date(),
          approvedBy: req.user!.id,
          completedAt: new Date(),
        });
        fireAutoMessageTriggers(req.params.id as string, "completed");
        res.json(updated);
      } else {
        const updated = await storage.updateApplication(req.params.id as string, {
          status: "level3_work",
          currentLevel: 2,
          level4Notes: notes,
          assignedAgentId: app.assignedAgentId,
        });
        fireAutoMessageTriggers(req.params.id as string, "rework");
        res.json(updated);
      }
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // ===========================================================================
  // ADMIN ROUTES
  // ===========================================================================

  app.get("/api/admin/users", requireAuth, requireLevel(3), async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      res.json(users.map((u) => ({ ...u, passwordHash: undefined })));
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.post("/api/admin/users", requireAuth, requireLevel(3), async (req, res) => {
    try {
      const {
        email, password, firstName, lastName, phone, userLevel,
        doctorProfile,
        doctorFullName, licenseNumber, npiNumber, deaNumber,
        doctorPhone, fax, doctorAddress, specialty
      } = req.body;

      if (!email || !password || !firstName || !lastName) {
        res.status(400).json({ message: "Email, password, first name, and last name are required" });
        return;
      }

      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        res.status(400).json({ message: "A user with this email already exists" });
        return;
      }

      const passwordHash = await bcrypt.hash(password, 10);
      const profileId = randomBytes(4).toString("hex").toUpperCase();
      const referralCode = randomBytes(4).toString("hex").toUpperCase();

      let firebaseUid: string | null = null;
      try {
        const adminAuth = getAdminAuth();
        const fbUser = await adminAuth.createUser({
          email,
          password,
          displayName: `${firstName} ${lastName}`,
        });
        firebaseUid = fbUser.uid;
      } catch (fbErr: any) {
        console.error("Firebase user creation failed (non-blocking):", fbErr.message);
      }

      const newUser = await storage.createUser({
        email,
        passwordHash,
        firstName,
        lastName,
        phone: phone || null,
        firebaseUid,
        userLevel: userLevel || 1,
        profileId,
        referralCode,
        isActive: true,
      });

      if (userLevel === 2) {
        const dp = doctorProfile || {};
        const dpFullName = dp.fullName || doctorFullName || `${firstName} ${lastName}`;
        const dpLicense = dp.licenseNumber || licenseNumber || "";
        const dpNPI = dp.npiNumber || npiNumber || null;
        const dpDEA = dp.deaNumber || deaNumber || null;
        const dpPhone = dp.phone || doctorPhone || phone || null;
        const dpFax = dp.fax || fax || null;
        const dpAddress = dp.address || doctorAddress || null;
        const dpSpecialty = dp.specialty || specialty || null;
        const dpState = dp.state || null;
        const dpFormTemplate = dp.formTemplate || null;

        await storage.createDoctorProfile({
          userId: newUser.id,
          firebaseUid,
          fullName: dpFullName,
          licenseNumber: dpLicense,
          npiNumber: dpNPI,
          deaNumber: dpDEA,
          phone: dpPhone,
          fax: dpFax,
          address: dpAddress,
          specialty: dpSpecialty,
          state: dpState,
          formTemplate: dpFormTemplate,
          isActive: true,
        });
      }

      // Send welcome email with login credentials
      const protocol = process.env.NODE_ENV === "production" ? "https" : "https";
      const host = req.get("host") || "localhost:5000";
      const loginUrl = `${protocol}://${host}/login`;

      const levelNames: Record<number, string> = { 1: "Applicant", 2: "Doctor", 3: "Admin", 4: "Owner" };

      sendWelcomeEmail({
        userEmail: email,
        userName: `${firstName} ${lastName}`,
        tempPassword: password,
        loginUrl,
        userLevel: userLevel || 1,
        levelName: levelNames[userLevel || 1] || "User",
      }).catch(err => console.error("Welcome email error:", err));

      await storage.createActivityLog({
        userId: req.user!.id,
        action: "admin_created_user",
        entityType: "user",
        entityId: newUser.id,
        details: { createdUserEmail: email, userLevel: userLevel || 1 },
      });

      res.status(201).json({ ...newUser, passwordHash: undefined });
    } catch (error: any) {
      console.error("Admin create user error:", error);
      res.status(500).json({ message: error.message || "Failed to create user" });
    }
  });

  app.get("/api/admin/applications", requireAuth, requireLevel(3), async (req, res) => {
    try {
      const applications = await storage.getAllApplications();
      res.json(applications);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.get("/api/admin/payments", requireAuth, requireLevel(3), async (req, res) => {
    try {
      const payments = await storage.getAllPayments();
      res.json(payments);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.get("/api/admin/commissions", requireAuth, requireLevel(3), async (req, res) => {
    try {
      const commissions = await storage.getAllCommissions();
      res.json(commissions);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // ===========================================================================
  // OWNER ROUTES (Site Configuration)
  // ===========================================================================

  app.put("/api/owner/config", requireAuth, requireLevel(4), async (req, res) => {
    try {
      const {
        siteName,
        tagline,
        description,
        logoUrl,
        faviconUrl,
        primaryColor,
        secondaryColor,
        accentColor,
        heroTitle,
        heroSubtitle,
        heroBackgroundUrl,
        heroMediaUrl,
        heroButtonText,
        heroButtonLink,
        heroSecondaryButtonText,
        heroSecondaryButtonLink,
        footerQuickLinks,
        footerLegalLinks,
        footerText,
        contactEmail,
        contactPhone,
        address,
        level1Name,
        level2Name,
        level3Name,
        level4Name,
        galleryImages: rawGalleryImages,
        aboutMediaUrl,
        ctaMediaUrl,
        contactMediaUrl,
        departmentMediaUrls,
        testimonialMediaUrls,
      } = req.body;

      const galleryImages = Array.isArray(rawGalleryImages)
        ? rawGalleryImages.filter((item: unknown) => typeof item === 'string' && item.length > 0)
        : undefined;

      const config = await storage.updateSiteConfig({
        siteName,
        tagline,
        description,
        logoUrl,
        faviconUrl,
        primaryColor,
        secondaryColor,
        accentColor,
        heroTitle,
        heroSubtitle,
        heroBackgroundUrl,
        heroMediaUrl,
        heroButtonText,
        heroButtonLink,
        heroSecondaryButtonText,
        heroSecondaryButtonLink,
        footerQuickLinks,
        footerLegalLinks,
        footerText,
        contactEmail,
        contactPhone,
        address,
        level1Name,
        level2Name,
        level3Name,
        level4Name,
        galleryImages,
        aboutMediaUrl,
        ctaMediaUrl,
        contactMediaUrl,
        departmentMediaUrls,
        testimonialMediaUrls,
      });

      res.json(config);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // Package management for owner/admin
  app.post("/api/admin/packages", requireAuth, requireLevel(3), async (req, res) => {
    try {
      const pkg = await storage.createPackage(req.body);
      res.json(pkg);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.put("/api/admin/packages/:id", requireAuth, requireLevel(3), async (req, res) => {
    try {
      const pkg = await storage.updatePackage(req.params.id as string, req.body);
      if (!pkg) {
        res.status(404).json({ message: "Package not found" });
        return;
      }
      res.json(pkg);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.delete("/api/admin/packages/:id", requireAuth, requireLevel(4), async (req, res) => {
    try {
      const success = await storage.deletePackage(req.params.id as string);
      if (!success) {
        res.status(404).json({ message: "Package not found" });
        return;
      }
      res.json({ message: "Package deleted" });
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // ============================================================================
  // SHARED USER PROFILE ENDPOINTS (Level 3+)
  // ============================================================================

  // Get user applications (for profile modal)
  app.get("/api/users/:id/applications", requireAuth, requireLevel(2), async (req, res) => {
    try {
      const apps = await storage.getApplicationsByUser(req.params.id as string);
      const packages = await storage.getActivePackages();
      const packagesMap = new Map(packages.map(p => [p.id, p]));
      
      const appsWithPackages = apps.map(app => ({
        ...app,
        package: app.packageId ? packagesMap.get(app.packageId) : undefined,
      }));
      
      res.json(appsWithPackages);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // Get user basic info (for edit tracking display)
  app.get("/api/users/:id/info", requireAuth, requireLevel(2), async (req, res) => {
    try {
      const user = await storage.getUser(req.params.id as string);
      if (!user) {
        res.status(404).json({ message: "User not found" });
        return;
      }
      res.json({ firstName: user.firstName, lastName: user.lastName });
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // Update user profile with edit tracking (Level 3+)
  app.put("/api/users/:id/profile", requireAuth, requireLevel(2), async (req, res) => {
    try {
      const { userLevel, isActive, firstName, lastName, email, phone, dateOfBirth, address, city, state, zipCode } = req.body;
      const updates: Record<string, any> = {
        lastEditedBy: req.user!.id,
        lastEditedAt: new Date(),
      };
      
      // Level 3 can only edit profile data, not level/status
      const currentUserLevel = req.user!.userLevel;
      
      if (currentUserLevel >= 3) {
        if (userLevel !== undefined) updates.userLevel = userLevel;
        if (isActive !== undefined) updates.isActive = isActive;
      }
      
      if (firstName !== undefined) updates.firstName = firstName;
      if (lastName !== undefined) updates.lastName = lastName;
      if (email !== undefined) updates.email = email;
      if (phone !== undefined) updates.phone = phone;
      if (dateOfBirth !== undefined) updates.dateOfBirth = dateOfBirth;
      if (address !== undefined) updates.address = address;
      if (city !== undefined) updates.city = city;
      if (state !== undefined) updates.state = state;
      if (zipCode !== undefined) updates.zipCode = zipCode;
      
      const user = await storage.updateUser(req.params.id as string, updates);
      if (!user) {
        res.status(404).json({ message: "User not found" });
        return;
      }
      res.json({ ...user, passwordHash: undefined });
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // Get user notes
  app.get("/api/users/:id/notes", requireAuth, requireLevel(2), async (req, res) => {
    try {
      const notes = await storage.getUserNotes(req.params.id as string);
      res.json(notes);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // Add user note
  app.post("/api/users/:id/notes", requireAuth, requireLevel(2), async (req, res) => {
    try {
      const { content } = req.body;
      if (!content || !content.trim()) {
        res.status(400).json({ message: "Note content is required" });
        return;
      }
      const note = await storage.createUserNote({
        userId: req.params.id as string,
        authorId: req.user!.id,
        content: content.trim(),
      });
      res.json(note);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // User management
  app.put("/api/admin/users/:id", requireAuth, requireLevel(3), async (req, res) => {
    try {
      const { userLevel, isActive, firstName, lastName, email, phone, dateOfBirth, address, city, state, zipCode } = req.body;
      const updates: Record<string, any> = {};
      if (userLevel !== undefined) updates.userLevel = userLevel;
      if (isActive !== undefined) updates.isActive = isActive;
      if (firstName !== undefined) updates.firstName = firstName;
      if (lastName !== undefined) updates.lastName = lastName;
      if (email !== undefined) updates.email = email;
      if (phone !== undefined) updates.phone = phone;
      if (dateOfBirth !== undefined) updates.dateOfBirth = dateOfBirth;
      if (address !== undefined) updates.address = address;
      if (city !== undefined) updates.city = city;
      if (state !== undefined) updates.state = state;
      if (zipCode !== undefined) updates.zipCode = zipCode;
      
      const user = await storage.updateUser(req.params.id as string, updates);
      if (!user) {
        res.status(404).json({ message: "User not found" });
        return;
      }
      res.json({ ...user, passwordHash: undefined });
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // Get a user's applications/purchases (for profile modal)
  app.get("/api/admin/users/:id/applications", requireAuth, requireLevel(3), async (req, res) => {
    try {
      const apps = await storage.getApplicationsByUser(req.params.id as string);
      const packages = await storage.getActivePackages();
      const packagesMap = new Map(packages.map(p => [p.id, p]));
      
      const appsWithPackages = apps.map(app => ({
        ...app,
        package: app.packageId ? packagesMap.get(app.packageId) : undefined,
      }));
      
      res.json(appsWithPackages);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // ===========================================================================
  // GIZMO FORM SYSTEM  PDF proxy + form data
  // ===========================================================================

  app.get("/api/forms/proxy-pdf", async (req, res) => {
    try {
      const url = req.query.url as string;
      if (!url) {
        res.status(400).json({ error: "url required" });
        return;
      }
      const response = await fetch(url);
      if (!response.ok) {
        res.status(502).json({ error: "Failed to fetch PDF" });
        return;
      }
      res.setHeader("Content-Type", "application/pdf");
      res.setHeader("Cache-Control", "no-store");
      const buffer = await response.arrayBuffer();
      res.send(Buffer.from(buffer));
    } catch (error: any) {
      res.status(500).json({ error: error.message || "Proxy fetch failed" });
    }
  });

  app.get("/api/forms/data/:applicationId", requireAuth, requireLevel(2), async (req, res) => {
    try {
      const application = await storage.getApplication(req.params.applicationId);
      if (!application) {
        res.status(404).json({ message: "Application not found" });
        return;
      }

      const applicant = await storage.getUser(application.userId);
      if (!applicant) {
        res.status(404).json({ message: "Applicant not found" });
        return;
      }

      let doctorProfile: Record<string, any> | undefined;
      if (application.assignedDoctorId) {
        doctorProfile = await storage.getDoctorProfile(application.assignedDoctorId);
        if (!doctorProfile) {
          doctorProfile = await storage.getDoctorProfileByUserId(application.assignedDoctorId);
        }
      }

      const formData = (application.formData as Record<string, any>) || {};
      const pkg = application.packageId ? await storage.getPackage(application.packageId) : null;

      const patientData: Record<string, string> = {
        firstName: applicant.firstName || formData.firstName || "",
        middleName: applicant.middleName || formData.middleName || "",
        lastName: applicant.lastName || formData.lastName || "",
        suffix: formData.suffix || "",
        dateOfBirth: applicant.dateOfBirth || formData.dateOfBirth || "",
        address: applicant.address || formData.address || "",
        apt: formData.apt || "",
        city: applicant.city || formData.city || "",
        state: applicant.state || formData.state || "",
        zipCode: applicant.zipCode || formData.zipCode || "",
        phone: applicant.phone || formData.phone || "",
        email: applicant.email || formData.email || "",
        medicalCondition: applicant.medicalCondition || formData.medicalCondition || "",
        idNumber: applicant.driverLicenseNumber || formData.driverLicenseNumber || "",
        idExpirationDate: formData.idExpirationDate || "",
        idType: formData.idType || "",
      };

      const doctorData: Record<string, string> = doctorProfile
        ? {
            firstName: (doctorProfile.fullName || "").split(" ")[0] || "",
            middleName: "",
            lastName: (doctorProfile.fullName || "").split(" ").slice(-1)[0] || "",
            phone: doctorProfile.phone || "",
            address: doctorProfile.address || "",
            city: "",
            state: doctorProfile.state || "",
            zipCode: "",
            licenseNumber: doctorProfile.licenseNumber || "",
            npiNumber: doctorProfile.npiNumber || "",
          }
        : {
            firstName: "", middleName: "", lastName: "",
            phone: "", address: "", city: "", state: "", zipCode: "",
            licenseNumber: "", npiNumber: "",
          };

      const gizmoFormUrl = doctorProfile?.formTemplate
        ? null
        : (formData.gizmoFormUrl || null);

      const today = new Date();
      const generatedDate = today.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
        day: "numeric",
      });

      res.json({
        success: true,
        patientData,
        doctorData,
        gizmoFormUrl,
        generatedDate,
        patientName: `${patientData.firstName} ${patientData.lastName}`.trim(),
        packageName: pkg?.name || "",
      });
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // ===========================================================================
  // DOCTOR PROFILES (Level 2+ for own, Level 3+ for all)
  // ===========================================================================

  app.get("/api/doctor-profiles", requireAuth, requireLevel(3), async (req, res) => {
    try {
      const profiles = await storage.getAllDoctorProfiles();
      res.json(profiles);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.get("/api/doctor-profiles/me", requireAuth, requireLevel(2), async (req, res) => {
    try {
      const profile = await storage.getDoctorProfileByUserId(req.user!.id);
      if (!profile) {
        res.status(404).json({ message: "Doctor profile not found" });
        return;
      }
      res.json(profile);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.get("/api/doctor-profiles/:id", requireAuth, requireLevel(2), async (req, res) => {
    try {
      const profile = await storage.getDoctorProfile(req.params.id as string);
      if (!profile) {
        res.status(404).json({ message: "Doctor profile not found" });
        return;
      }
      if (profile.userId !== req.user!.id && req.user!.userLevel < 3) {
        res.status(403).json({ message: "Not authorized to view this profile" });
        return;
      }
      res.json(profile);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.post("/api/doctor-profiles", requireAuth, requireLevel(2), async (req, res) => {
    try {
      const { fullName, licenseNumber, npiNumber, deaNumber, phone, fax, address, specialty, bio } = req.body;
      if (!fullName || !licenseNumber) {
        res.status(400).json({ message: "fullName and licenseNumber are required" });
        return;
      }
      const existing = await storage.getDoctorProfileByUserId(req.user!.id);
      if (existing) {
        res.status(400).json({ message: "Doctor profile already exists. Use PUT to update." });
        return;
      }
      const profile = await storage.createDoctorProfile({
        fullName, licenseNumber, npiNumber, deaNumber, phone, fax, address, specialty, bio,
        userId: req.user!.id,
        firebaseUid: req.user!.firebaseUid,
      });
      res.status(201).json(profile);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.put("/api/doctor-profiles/:id", requireAuth, requireLevel(2), async (req, res) => {
    try {
      const profile = await storage.getDoctorProfile(req.params.id as string);
      if (!profile) {
        res.status(404).json({ message: "Doctor profile not found" });
        return;
      }
      if (profile.userId !== req.user!.id && req.user!.userLevel < 3) {
        res.status(403).json({ message: "Not authorized to update this profile" });
        return;
      }
      const { fullName, licenseNumber, npiNumber, deaNumber, phone, fax, address, specialty, bio } = req.body;
      const updateData: Record<string, any> = {};
      if (fullName !== undefined) updateData.fullName = fullName;
      if (licenseNumber !== undefined) updateData.licenseNumber = licenseNumber;
      if (npiNumber !== undefined) updateData.npiNumber = npiNumber;
      if (deaNumber !== undefined) updateData.deaNumber = deaNumber;
      if (phone !== undefined) updateData.phone = phone;
      if (fax !== undefined) updateData.fax = fax;
      if (address !== undefined) updateData.address = address;
      if (specialty !== undefined) updateData.specialty = specialty;
      if (bio !== undefined) updateData.bio = bio;
      const updated = await storage.updateDoctorProfile(req.params.id as string, updateData);
      res.json(updated);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // ===========================================================================
  // AUTO-MESSAGE TRIGGERS (Level 3+ Admin/Owner)
  // ===========================================================================

  app.get("/api/auto-message-triggers/:packageId", requireAuth, async (req, res) => {
    try {
      const triggers = await storage.getAutoMessageTriggers(req.params.packageId as string);
      res.json(triggers);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.post("/api/auto-message-triggers", requireAuth, requireLevel(3), async (req, res) => {
    try {
      const { packageId, triggerStatus, messageTemplate, recipientType } = req.body;
      if (!packageId || !triggerStatus || !messageTemplate) {
        res.status(400).json({ message: "packageId, triggerStatus, and messageTemplate are required" });
        return;
      }
      const trigger = await storage.createAutoMessageTrigger({
        packageId,
        triggerStatus,
        messageTemplate,
        recipientType: recipientType || "patient",
        createdBy: req.user!.id,
      });
      res.status(201).json(trigger);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.put("/api/auto-message-triggers/:id", requireAuth, requireLevel(3), async (req, res) => {
    try {
      const { id, createdAt, createdBy, ...updateData } = req.body;
      const updated = await storage.updateAutoMessageTrigger(req.params.id as string, updateData);
      if (!updated) {
        res.status(404).json({ message: "Trigger not found" });
        return;
      }
      res.json(updated);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.delete("/api/auto-message-triggers/:id", requireAuth, requireLevel(3), async (req, res) => {
    try {
      await storage.deleteAutoMessageTrigger(req.params.id as string);
      res.json({ success: true });
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // ===========================================================================
  // FIREBASE INITIALIZATION / SEED ENDPOINT
  // ===========================================================================

  app.post("/api/admin/seed-firebase", async (req, res) => {
    try {
      const existingUsers = await storage.getAllUsers();
      if (existingUsers.length > 0) {
        const authHeader = req.headers.authorization;
        const token = authHeader?.startsWith("Bearer ") ? authHeader.slice(7) : null;
        const bootstrapToken = process.env.BOOTSTRAP_TOKEN;
        if (!bootstrapToken || token !== bootstrapToken) {
          res.status(403).json({ message: "System already initialized. Re-seeding requires a valid BOOTSTRAP_TOKEN." });
          return;
        }
      }

      const results: Record<string, any> = {
        counters: false,
        siteConfig: false,
        adminSettings: false,
        commissionSettings: false,
        packages: 0,
        ownerUser: false,
        collections_initialized: [] as string[],
        errors: [] as string[],
      };

      // 1. Initialize _counters collection (ChronicDocs pattern)
      try {
        await storage.initializeCounters();
        results.counters = true;
      } catch (e: any) {
        (results.errors as string[]).push(`Counters init failed: ${e.message}`);
      }

      // 2. Site config - always update with latest defaults to ensure branding is current
      const existingConfig = await storage.getSiteConfig();
      if (!existingConfig) {
        const { levelNames, features, ...flatConfig } = defaultConfig as any;
        await storage.updateSiteConfig({
          ...flatConfig,
          level1Name: defaultConfig.levelNames.level1,
          level2Name: defaultConfig.levelNames.level2,
          level3Name: defaultConfig.levelNames.level3,
          level4Name: defaultConfig.levelNames.level4,
        } as any);
        results.siteConfig = true;
      } else {
        await storage.updateSiteConfig({
          siteName: defaultConfig.siteName,
          tagline: defaultConfig.tagline,
          description: defaultConfig.description,
          heroTitle: defaultConfig.heroTitle,
          heroSubtitle: defaultConfig.heroSubtitle,
          heroButtonText: defaultConfig.heroButtonText,
          heroButtonLink: defaultConfig.heroButtonLink,
          heroSecondaryButtonText: defaultConfig.heroSecondaryButtonText,
          heroSecondaryButtonLink: defaultConfig.heroSecondaryButtonLink,
          level1Name: defaultConfig.levelNames.level1,
          level2Name: defaultConfig.levelNames.level2,
          level3Name: defaultConfig.levelNames.level3,
          level4Name: defaultConfig.levelNames.level4,
          workflowSteps: defaultConfig.workflowSteps,
          footerQuickLinks: defaultConfig.footerQuickLinks,
          footerLegalLinks: defaultConfig.footerLegalLinks,
        } as any);
        results.siteConfig = "updated";
      }

      // 3. Admin settings (ChronicDocs pattern)
      const existingAdmin = await storage.getAdminSettings();
      if (!existingAdmin) {
        await storage.updateAdminSettings({
          availableStates: ["OK", "TX", "FL", "CA", "NY"],
          maintenanceMode: false,
          registrationOpen: true,
          maxQueueSize: 50,
          autoAssignAgents: true,
          defaultWorkflowSteps: 6,
        });
        results.adminSettings = true;
        results.collections_initialized.push("adminSettings");
      } else {
        results.adminSettings = "already_exists";
      }

      // 4. Commission settings (ChronicDocs pattern)
      const existingCommSettings = await storage.getCommissionSettings();
      if (!existingCommSettings) {
        await storage.updateCommissionSettings({
          defaultRate: 10,
          agentCommissionPercent: 15,
          autoApprove: false,
          minPayoutAmount: 5000,
          payoutSchedule: "monthly",
        });
        results.commissionSettings = true;
        results.collections_initialized.push("commissionSettings");
      } else {
        results.commissionSettings = "already_exists";
      }

      // 5. Packages
      const existingPackages = await storage.getActivePackages();
      if (existingPackages.length === 0) {
        const seedPackages = [
          {
            name: "ESA Letter",
            description: "Emotional Support Animal letter for housing and travel. Reviewed and signed by a licensed professional.",
            price: 4999,
            isActive: true,
            requiresLevel2: false,
            features: ["Same-day delivery", "Digital copy", "Verification number"],
            category: "standard",
          },
          {
            name: "Housing ESA Certification",
            description: "Comprehensive ESA certification for landlords and housing providers. Compliant with the Fair Housing Act.",
            price: 7999,
            isActive: true,
            requiresLevel2: true,
            features: ["Priority processing", "Professional consultation", "Detailed documentation", "Print-ready PDF"],
            category: "urgent",
          },
          {
            name: "PSD Letter",
            description: "Psychiatric Service Dog letter with professional evaluation. Includes follow-up recommendations.",
            price: 12999,
            isActive: true,
            requiresLevel2: true,
            features: ["Professional evaluation", "Comprehensive documentation", "Follow-up plan", "Priority support"],
            category: "specialist",
          },
        ];

        for (const pkg of seedPackages) {
          try {
            await storage.createPackage(pkg as any);
            results.packages++;
          } catch (e: any) {
            (results.errors as string[]).push(`Failed to create package ${pkg.name}: ${e.message}`);
          }
        }
      } else {
        results.packages = `${existingPackages.length}_already_exist`;
      }

      // 6. Test accounts for all 4 levels (ChronicDocs pattern)
      const testPassword = "TestPass123";
      const hashedTestPassword = await bcrypt.hash(testPassword, 10);
      const testAccounts = [
        { email: "level1@test.com", firstName: "Test", lastName: "Patient", userLevel: 1, referralCode: "TEST_L1" },
        { email: "level2@test.com", firstName: "Test", lastName: "Doctor", userLevel: 2, referralCode: "TEST_L2" },
        { email: "level3@test.com", firstName: "Test", lastName: "Admin", userLevel: 3, referralCode: "TEST_L3" },
        { email: "level4@test.com", firstName: "Test", lastName: "Owner", userLevel: 4, referralCode: "TEST_L4" },
      ];

      results.testAccounts = [] as string[];
      for (const acct of testAccounts) {
        try {
          const existing = await storage.getUserByEmail(acct.email);
          if (existing) {
            await storage.updateUser(existing.id, { passwordHash: hashedTestPassword } as any);
            (results.testAccounts as string[]).push(`${acct.email} (Level ${acct.userLevel}) - updated`);
          } else {
            await storage.createUser({
              ...acct,
              passwordHash: hashedTestPassword,
              isActive: true,
            } as any);
            (results.testAccounts as string[]).push(`${acct.email} (Level ${acct.userLevel}) - created`);
          }
        } catch (e: any) {
          (results.errors as string[]).push(`Failed to create ${acct.email}: ${e.message}`);
        }
      }

      // Also ensure owner account exists as Level 4
      const allUsers = await storage.getAllUsers();
      const hasOwner = allUsers.some((u: any) => u.userLevel === 4 && u.email === "owner@supportanimalregistry.com");
      if (!hasOwner) {
        try {
          const ownerEmail = req.body?.email || "owner@supportanimalregistry.com";
          const ownerPassword = req.body?.password || testPassword;
          const hashedOwnerPw = await bcrypt.hash(ownerPassword, 10);
          await storage.createUser({
            email: ownerEmail,
            passwordHash: hashedOwnerPw,
            firstName: "Platform",
            lastName: "Owner",
            userLevel: 4,
            isActive: true,
            referralCode: "OWNER001",
          } as any);
          results.ownerUser = true;
        } catch (e: any) {
          (results.errors as string[]).push(`Failed to create owner: ${e.message}`);
        }
      } else {
        results.ownerUser = "already_exists";
      }

      // 7. Initialize remaining collections with placeholder docs using proper storage methods
      // ChronicDocs pattern: all collections exist in Firestore from the start
      const initCollection = async (name: string, checkFn: () => Promise<any>, createFn: () => Promise<any>) => {
        try {
          const existing = await checkFn();
          const isEmpty = Array.isArray(existing) ? existing.length === 0 : !existing;
          if (isEmpty) {
            await createFn();
            results.collections_initialized.push(name);
          }
        } catch (e: any) {
          (results.errors as string[]).push(`Failed to init ${name}: ${e.message}`);
        }
      };

      await initCollection("formTemplates",
        () => storage.getFormTemplates(),
        () => storage.createFormTemplate({ name: "Default Template", description: "System template", isActive: true, fields: [] })
      );
      await initCollection("formTypes",
        () => storage.getFormTypes(),
        () => storage.createFormType({ name: "Registration Form", description: "Standard support animal registration form", isActive: true })
      );
      await initCollection("bulletin",
        () => storage.getBulletins(),
        () => storage.createBulletin({ title: "Welcome", message: "Platform is live and ready.", isActive: true, priority: "normal", targetLevels: [1, 2, 3, 4] })
      );
      await initCollection("termsOfService",
        () => storage.getTermsOfService(),
        () => storage.updateTermsOfService({ version: "1.0", content: "Terms of Service placeholder. Update this with your actual terms.", isActive: true })
      );
      await initCollection("systemReferralCodes",
        () => storage.getSystemReferralCodes(),
        () => storage.createSystemReferralCode({ code: "WELCOME2025", discountPercent: 10, isActive: true, description: "Welcome discount" })
      );
      await initCollection("blogPosts",
        () => storage.getBlogPosts(),
        () => storage.createBlogPost({ title: "Welcome to Our Platform", content: "We are excited to launch our support animal registration service.", isPublished: true, authorId: "system" })
      );

      // 8. Initialize ALL remaining collections with placeholder docs so they appear in Firestore
      const remainingCollections: { name: string; doc: Record<string, any> }[] = [
        { name: "approvals", doc: { type: "system_init", status: "placeholder" } },
        { name: "errorLogs", doc: { level: "info", message: "Collection initialized", source: "seed" } },
        { name: "documentStates", doc: { status: "initialized", description: "Collection initialized" } },
        { name: "consultationHistory", doc: { type: "system_init", status: "placeholder" } },
        { name: "formAssignments", doc: { type: "system_init", status: "placeholder" } },
        { name: "workflowInstances", doc: { type: "system_init", status: "placeholder" } },
        { name: "agentQueue", doc: { type: "system_init", status: "placeholder" } },
        { name: "agentClockRecords", doc: { type: "system_init", status: "placeholder" } },
        { name: "applicationStatus", doc: { type: "system_init", currentStep: 0, status: "placeholder" } },
        { name: "stepData", doc: { type: "system_init", step: 0, status: "placeholder" } },
        { name: "profileNotes", doc: { type: "system_init", note: "Collection initialized" } },
        { name: "pushSubscriptions", doc: { type: "system_init", status: "placeholder" } },
        { name: "chargebacks", doc: { type: "system_init", status: "placeholder", amount: 0 } },
        { name: "referralCodeHistory", doc: { type: "system_init", status: "placeholder" } },
        { name: "referralRegistrations", doc: { type: "system_init", status: "placeholder" } },
        { name: "termsAcceptances", doc: { type: "system_init", status: "placeholder" } },
        { name: "agentDocuments", doc: { type: "system_init", status: "placeholder" } },
        { name: "doctorProfiles", doc: { type: "system_init", status: "placeholder", specialty: "General" } },
        { name: "autoMessageTriggers", doc: { type: "system_init", status: "placeholder", triggerStatus: "none" } },
      ];

      for (const col of remainingCollections) {
        try {
          const created = await storage.initCollectionWithPlaceholder(col.name, col.doc);
          if (created) {
            results.collections_initialized.push(col.name);
          }
        } catch (e: any) {
          (results.errors as string[]).push(`Failed to init ${col.name}: ${e.message}`);
        }
      }

      res.json({
        success: true,
        message: "Firebase seed complete - all Support Animal Registry collections initialized",
        details: results,
      });
    } catch (error: any) {
      console.error("Seed error:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // ===========================================================================
  // DATA MIGRATION ENDPOINT (PostgreSQL + Local Files -> Firebase)
  // ===========================================================================

  app.post("/api/admin/migrate-to-firebase", requireAuth, requireLevel(4), async (req, res) => {
    try {
      const results: Record<string, any> = { images: 0, errors: [] as string[] };

      const config = await storage.getSiteConfig();
      if (config && config.galleryImages && Array.isArray(config.galleryImages)) {
        const newUrls: string[] = [];
        for (const imageUrl of config.galleryImages) {
          if (imageUrl.startsWith("/uploads/gallery/")) {
            const localPath = path.join(process.cwd(), imageUrl);
            if (fs.existsSync(localPath)) {
              try {
                const fileBuffer = fs.readFileSync(localPath);
                const ext = path.extname(localPath).toLowerCase();
                const mimeMap: Record<string, string> = {
                  ".jpg": "image/jpeg", ".jpeg": "image/jpeg",
                  ".png": "image/png", ".gif": "image/gif",
                  ".webp": "image/webp", ".svg": "image/svg+xml",
                };
                const bucket = firebaseStorage.bucket();
                const fileName = `gallery/${path.basename(localPath)}`;
                const storageFile = bucket.file(fileName);
                await storageFile.save(fileBuffer, {
                  metadata: { contentType: mimeMap[ext] || "image/jpeg" },
                });
                await storageFile.makePublic();
                const firebaseUrl = `https://storage.googleapis.com/${bucket.name}/${fileName}`;
                newUrls.push(firebaseUrl);
                results.images++;
              } catch (e: any) {
                (results.errors as string[]).push(`Failed to migrate ${imageUrl}: ${e.message}`);
                newUrls.push(imageUrl);
              }
            } else {
              newUrls.push(imageUrl);
            }
          } else {
            newUrls.push(imageUrl);
          }
        }

        if (results.images > 0) {
          await storage.updateSiteConfig({ galleryImages: newUrls } as any);
        }
      }

      res.json({
        success: true,
        message: `Migration complete. ${results.images} images migrated to Firestore.`,
        details: results,
      });
    } catch (error: any) {
      console.error("Migration error:", error);
      res.status(500).json({ message: error.message });
    }
  });

  return httpServer;
}
