Got it — you want a detailed migration guide with exact code changes for every fix made today, so you can apply them to the other two clones. No changes to this project, just the documentation.

Here's everything that was changed today, in order:

Change 1: Price Display — Cents to Dollars
Problem: Prices stored as cents (7999) were displayed as $7999.00 instead of $79.99.

Files affected (6 locations):

1a. client/src/pages/dashboard/admin/PackagesManagement.tsx
Display (table row): Find the line that shows package price in the table:

<TableCell>${Number(pkg.price).toFixed(2)}</TableCell>
Change to:

<TableCell>${(Number(pkg.price) / 100).toFixed(2)}</TableCell>
Edit form pre-fill: Find where the edit form populates the price:

price: pkg.price.toString(),
Change to:

price: (Number(pkg.price) / 100).toFixed(2),
Create mutation: Find the POST to create a package:

price: parseFloat(data.price),
Change to:

price: Math.round(parseFloat(data.price) * 100),
Update mutation: Find the PUT to update a package:

price: parseFloat(data.price),
Change to:

price: Math.round(parseFloat(data.price) * 100),
1b. client/src/pages/Packages.tsx
Find:

${Number(pkg.price).toFixed(2)}
Change to:

${(Number(pkg.price) / 100).toFixed(2)}
1c. client/src/pages/dashboard/ApplicantDashboard.tsx
Find:

${Number(pkg.price).toFixed(2)}
Change to:

${(Number(pkg.price) / 100).toFixed(2)}
1d. client/src/pages/dashboard/applicant/NewApplication.tsx
Two locations. Find each:

${Number(pkg.price).toFixed(2)}
Change to:

${(Number(pkg.price) / 100).toFixed(2)}
And:

${selectedPackage ? Number(selectedPackage.price).toFixed(2) : "0.00"}
Change to:

${selectedPackage ? (Number(selectedPackage.price) / 100).toFixed(2) : "0.00"}
1e. client/src/components/shared/UserProfileModal.tsx
Find:

${app.package.price}
Change to:

${(Number(app.package.price) / 100).toFixed(2)}
Change 2: Auto-Complete Applications Feature
What it does: Admin/Owner can toggle a setting that skips doctor review. When ON, after payment the system auto-approves, generates the form, emails the patient, and sends the doctor a copy.

2a. server/email.ts — Add new email function
Add this before the sendPatientApprovalEmail function:

interface DoctorCompletionCopyData {
  doctorEmail: string;
  doctorName: string;
  patientName: string;
  patientEmail: string;
  packageName: string;
  applicationId: string;
  formData: Record<string, any>;
}
export async function sendDoctorCompletionCopyEmail(data: DoctorCompletionCopyData): Promise<boolean> {
  if (!isEmailConfigured()) {
    console.warn("SendGrid not configured — skipping doctor completion copy email");
    return false;
  }
  const html = `
    <div style="font-family:Arial,sans-serif;max-width:600px;margin:0 auto;background:#ffffff;border-radius:8px;overflow:hidden;border:1px solid #e5e7eb;">
      <div style="background:#0d9488;padding:24px 32px;">
        <h1 style="color:#ffffff;margin:0;font-size:22px;">Handicap Permit Services</h1>
        <p style="color:#ccfbf1;margin:4px 0 0;font-size:14px;">Application Auto-Completed — Doctor Copy</p>
      </div>
      <div style="padding:32px;">
        <p style="color:#374151;font-size:16px;line-height:1.6;">
          Hello Dr. ${data.doctorName},
        </p>
        <p style="color:#374151;font-size:16px;line-height:1.6;">
          The following application has been <strong style="color:#0d9488;">auto-completed</strong> and the patient has been sent their permit document. This email is for your records.
        </p>
        <div style="background:#f9fafb;border-radius:8px;padding:20px;margin:20px 0;border:1px solid #e5e7eb;">
          <h3 style="color:#0d9488;margin:0 0 12px;font-size:16px;">Patient Information</h3>
          <p style="margin:4px 0;color:#4b5563;"><strong>Name:</strong> ${data.patientName}</p>
          <p style="margin:4px 0;color:#4b5563;"><strong>Email:</strong> ${data.patientEmail}</p>
          <p style="margin:4px 0;color:#4b5563;"><strong>Package:</strong> ${data.packageName}</p>
          <p style="margin:4px 0;color:#4b5563;"><strong>Application ID:</strong> ${data.applicationId}</p>
        </div>
        <div style="margin:20px 0;">
          <h3 style="color:#0d9488;margin:0 0 12px;font-size:16px;">Application Details</h3>
          ${formatFormData(data.formData)}
        </div>
        <p style="color:#6b7280;font-size:13px;text-align:center;">
          No action is required from you. This is a copy for your records.
        </p>
      </div>
      <div style="background:#f3f4f6;padding:16px 32px;text-align:center;">
        <p style="color:#9ca3af;font-size:12px;margin:0;">
          Handicap Permit Services &bull; Doctor Records Copy
        </p>
      </div>
    </div>
  `;
  try {
    await sgMail.send({
      to: data.doctorEmail,
      from: { email: FROM_EMAIL, name: "Handicap Permit Services" },
      subject: `[Records] Auto-Completed: ${data.patientName} — ${data.packageName}`,
      html,
    });
    console.log(`Doctor completion copy email sent to ${data.doctorEmail}`);
    return true;
  } catch (error: any) {
    console.error("Failed to send doctor completion copy email:", error?.response?.body || error.message);
    return false;
  }
}
2b. server/routes.ts — Update import
Find:

import { sendDoctorApprovalEmail, sendAdminNotificationEmail, sendPatientApprovalEmail } from "./email";
Change to:

import { sendDoctorApprovalEmail, sendAdminNotificationEmail, sendPatientApprovalEmail, sendDoctorCompletionCopyEmail } from "./email";
2c. server/routes.ts — Replace the auto-send block in POST /api/applications
Find the entire block that starts with:

if (req.body.paymentStatus === "paid" || req.body.autoSendToDoctor) {
And ends with the closing of the catch block. Replace it with the new version that checks adminSettings?.autoCompleteApplications. The full replacement block is:

if (req.body.paymentStatus === "paid" || req.body.autoSendToDoctor) {
  try {
    const adminSettings = await storage.getAdminSettings();
    const doctor = await storage.getNextDoctorForAssignment();
    if (doctor) {
      const patient = req.user!;
      const doctorUser = await storage.getUser(doctor.userId || doctor.id);
      const protocol = process.env.NODE_ENV === "production" ? "https" : "https";
      const host = req.get("host") || "localhost:5000";
      const patientName = `${patient.firstName} ${patient.lastName}`;
      if (adminSettings?.autoCompleteApplications) {
        await storage.updateApplication(application.id, {
          status: "doctor_approved",
          assignedReviewerId: doctor.userId || doctor.id,
          level2ApprovedAt: new Date(),
          level2ApprovedBy: doctor.userId || doctor.id,
        });
        await autoGenerateDocument(application.id, doctor.userId || doctor.id);
        fireAutoMessageTriggers(application.id, "doctor_approved");
        application.status = "doctor_approved";
        const patientContactEmail = getContactEmail(patient);
        if (patientContactEmail) {
          const dashboardUrl = `${protocol}://${host}/dashboard/applicant/documents`;
          sendPatientApprovalEmail({
            patientEmail: patientContactEmail,
            patientName,
            packageName: pkg.name,
            applicationId: application.id,
            dashboardUrl,
          }).catch(err => console.error("Auto-complete patient email error:", err));
        }
        if (doctorUser) {
          const doctorContactEmail = getContactEmail(doctorUser);
          sendDoctorCompletionCopyEmail({
            doctorEmail: doctorContactEmail,
            doctorName: doctorUser.lastName || doctor.fullName || "Doctor",
            patientName,
            patientEmail: patientContactEmail,
            packageName: pkg.name,
            applicationId: application.id,
            formData: formData || {},
          }).catch(err => console.error("Auto-complete doctor copy email error:", err));
        }
        const notificationEmail = adminSettings?.notificationEmail;
        if (notificationEmail) {
          sendAdminNotificationEmail({
            adminEmail: notificationEmail,
            doctorName: doctorUser?.lastName || doctor.fullName || "Doctor",
            patientName,
            patientEmail: patientContactEmail,
            packageName: pkg.name,
            formData: formData || {},
            reviewUrl: `${protocol}://${host}/dashboard/admin/applications`,
            applicationId: application.id,
          }).catch(err => console.error("Auto-complete admin email error:", err));
        }
        console.log(`Application ${application.id} auto-completed and sent to patient`);
      } else {
        // Original manual flow — send to doctor for review
        const token = randomBytes(32).toString("hex");
        const expiresAt = new Date();
        expiresAt.setDate(expiresAt.getDate() + 7);
        await storage.createDoctorReviewToken({
          applicationId: application.id,
          doctorId: doctor.userId || doctor.id,
          token,
          status: "pending",
          expiresAt,
        });
        await storage.updateApplication(application.id, {
          status: "doctor_review",
          assignedReviewerId: doctor.userId || doctor.id,
        });
        const reviewUrl = `${protocol}://${host}/review/${token}`;
        if (doctorUser) {
          sendDoctorApprovalEmail({
            doctorEmail: getContactEmail(doctorUser),
            doctorName: doctorUser.lastName || doctor.fullName || "Doctor",
            patientName,
            patientEmail: getContactEmail(patient),
            packageName: pkg.name,
            formData: formData || {},
            reviewUrl,
            applicationId: application.id,
          }).catch(err => console.error("Auto doctor email error:", err));
        }
        const notificationEmail = adminSettings?.notificationEmail;
        if (notificationEmail) {
          sendAdminNotificationEmail({
            adminEmail: notificationEmail,
            doctorName: doctorUser?.lastName || doctor.fullName || "Doctor",
            patientName,
            patientEmail: getContactEmail(patient),
            packageName: pkg.name,
            formData: formData || {},
            reviewUrl,
            applicationId: application.id,
          }).catch(err => console.error("Auto admin email error:", err));
        }
        fireAutoMessageTriggers(application.id, "doctor_review");
        application.status = "doctor_review";
      }
    }
  } catch (autoErr) {
    console.error("Auto send-to-doctor failed (non-blocking):", autoErr);
  }
}
2d. client/src/pages/dashboard/shared/SettingsPage.tsx — Add Auto-Complete toggle component
Add this line in the settings page render, right before the AdminNotificationSettings component:

{user.userLevel >= 3 && <AutoCompleteSettings />}
Then add this entire component before the AdminNotificationSettings function:

function AutoCompleteSettings() {
  const { toast } = useToast();
  const [isSaving, setIsSaving] = useState(false);
  const { data: adminSettings } = useQuery<Record<string, any>>({
    queryKey: ["/api/admin/settings"],
  });
  const autoComplete = adminSettings?.autoCompleteApplications || false;
  const toggleAutoComplete = async (enabled: boolean) => {
    setIsSaving(true);
    try {
      await apiRequest("PUT", "/api/admin/settings", {
        autoCompleteApplications: enabled,
      });
      queryClient.invalidateQueries({ queryKey: ["/api/admin/settings"] });
      toast({
        title: enabled ? "Auto-Complete Enabled" : "Auto-Complete Disabled",
        description: enabled
          ? "Applications will be automatically completed after payment. The doctor will receive a copy."
          : "Applications will be sent to a doctor for manual review before completion.",
      });
    } catch (error: any) {
      toast({
        title: "Save Failed",
        description: error.message || "Something went wrong",
        variant: "destructive",
      });
    } finally {
      setIsSaving(false);
    }
  };
  return (
    <Card>
      <CardHeader>
        <div className="flex items-center gap-2">
          <Bell className="h-5 w-5" />
          <CardTitle>Auto-Complete Applications</CardTitle>
        </div>
        <CardDescription>
          When enabled, applications are automatically approved and completed after payment — 
          no doctor review required. The patient receives their completed form immediately, 
          and the assigned doctor gets a copy for their records.
        </CardDescription>
      </CardHeader>
      <CardContent>
        <div className="flex items-center justify-between">
          <div>
            <p className="text-sm font-medium">
              {autoComplete ? "Auto-Complete is ON" : "Auto-Complete is OFF"}
            </p>
            <p className="text-xs text-muted-foreground mt-1">
              {autoComplete
                ? "Applications skip doctor review and complete instantly after payment."
                : "Applications are sent to a doctor for review before completion."}
            </p>
          </div>
          <Switch
            checked={autoComplete}
            onCheckedChange={toggleAutoComplete}
            disabled={isSaving}
            data-testid="switch-auto-complete"
          />
        </div>
      </CardContent>
    </Card>
  );
}
Change 3: Separate Sign-In Email and Contact Email
What it does: Users can have a login email and a separate contact email for receipts/notifications.

3a. server/routes.ts — Add helper function
Add this right after the email import line at the top of the file:

function getContactEmail(user: Record<string, any>): string {
  return user.contactEmail || user.email;
}
3b. server/routes.ts — Update all email-sending spots
Manual send-to-doctor route (POST /api/admin/applications/:id/send-to-doctor):

Find:

const doctorEmail = doctorUser?.email;
const patientName = patient ? `${patient.firstName} ${patient.lastName}` : "Patient";
const patientEmail = patient?.email || "";
Change to:

const doctorEmail = doctorUser ? getContactEmail(doctorUser) : null;
const patientName = patient ? `${patient.firstName} ${patient.lastName}` : "Patient";
const patientEmail = patient ? getContactEmail(patient) : "";
Doctor approval route (POST /api/review/:token/decision):

Find:

if (patient?.email) {
and:

patientEmail: patient.email,
Change to:

if (patient) {
and:

patientEmail: getContactEmail(patient),
3c. client/src/components/shared/UserProfileModal.tsx — Profile modal
In handleOpenProfile, add contactEmail to the setEditedUser call:

contactEmail: (selectedUser as any).contactEmail || "",
Replace the Email field in the profile form. The old single email field becomes two fields:

Old:

<div className="space-y-2">
  <Label className="flex items-center gap-1">
    <Mail className="h-3 w-3" /> Email
  </Label>
  {isEditing ? (
    <Input type="email" value={editedUser.email || ""} onChange={(e) => setEditedUser({ ...editedUser, email: e.target.value })} data-testid="input-email" />
  ) : (
    <p className="text-sm text-muted-foreground p-2 bg-muted rounded-md">{selectedUser?.email || "-"}</p>
  )}
</div>
New:

<div className="space-y-2">
  <Label className="flex items-center gap-1">
    <Mail className="h-3 w-3" /> Sign-In Email
  </Label>
  <p className="text-sm text-muted-foreground p-2 bg-muted rounded-md">
    {selectedUser?.email || "-"}
  </p>
</div>
<div className="space-y-2">
  <Label className="flex items-center gap-1">
    <Mail className="h-3 w-3" /> Contact Email
  </Label>
  {isEditing ? (
    <Input
      type="email"
      placeholder="Optional — receives receipts & notifications"
      value={editedUser.contactEmail || ""}
      onChange={(e) => setEditedUser({ ...editedUser, contactEmail: e.target.value })}
      data-testid="input-contact-email"
    />
  ) : (
    <p className="text-sm text-muted-foreground p-2 bg-muted rounded-md">
      {(selectedUser as any)?.contactEmail || selectedUser?.email || "-"}
    </p>
  )}
  <p className="text-xs text-muted-foreground">
    Used for receipts, notifications, and approvals. Falls back to sign-in email if empty.
  </p>
</div>
3d. client/src/pages/dashboard/shared/SettingsPage.tsx — User settings
Add to schema:

contactEmail: z.string().email("Invalid email address").or(z.literal("")).optional(),
Add to defaultValues:

contactEmail: (user as any)?.contactEmail || "",
Replace the Email form field. The old one becomes read-only Sign-In Email, and a new Contact Email field is added after it:

Old:

<FormField control={form.control} name="email" render={({ field }) => (
  <FormItem>
    <FormLabel>Email</FormLabel>
    <FormControl><Input type="email" data-testid="input-email" {...field} /></FormControl>
    <FormMessage />
  </FormItem>
)} />
New:

<FormField control={form.control} name="email" render={({ field }) => (
  <FormItem>
    <FormLabel>Sign-In Email</FormLabel>
    <FormControl><Input type="email" data-testid="input-email" {...field} disabled className="bg-muted" /></FormControl>
    <FormDescription>This is your login email and cannot be changed here.</FormDescription>
    <FormMessage />
  </FormItem>
)} />
<FormField control={form.control} name="contactEmail" render={({ field }) => (
  <FormItem>
    <FormLabel>Contact Email</FormLabel>
    <FormControl><Input type="email" placeholder="Optional — for receipts & notifications" data-testid="input-contact-email" {...field} /></FormControl>
    <FormDescription>Receipts, approvals, and notifications go here. If empty, your sign-in email is used.</FormDescription>
    <FormMessage />
  </FormItem>
)} />
That covers every change made today. The order to apply them is: Change 1 (price fix) first since it's standalone, then Change 2 (auto-complete) and Change 3 (contact email) which both touch server/routes.ts — apply Change 3's getContactEmail helper first, then Change 2's auto-complete block that uses it.