Here's the complete migration guide for the Manual Payment feature. Two files are changed, plus a new backend endpoint.

Manual Payment Feature — Migration Guide
This feature adds a green $ button on the admin Users page next to every Applicant-level user. Clicking it opens a dialog where the admin selects a package and types a reason. On confirm, the system creates a full application as if the patient paid themselves — triggering auto-complete (or doctor review), emails, and activity logging.

File 1: server/routes.ts — New API Endpoint
Add this entire new route before the existing POST /api/admin/applications/:id/send-to-doctor route:

app.post("/api/admin/users/:userId/manual-payment", requireAuth, requireLevel(3), async (req, res) => {
    try {
      const { packageId, reason } = req.body;
      if (!packageId) {
        res.status(400).json({ message: "Package is required" });
        return;
      }
      const targetUser = await storage.getUser(req.params.userId as string);
      if (!targetUser) {
        res.status(404).json({ message: "User not found" });
        return;
      }
      const pkg = await storage.getPackage(packageId);
      if (!pkg) {
        res.status(400).json({ message: "Invalid package" });
        return;
      }
      const workflowSteps = (pkg.workflowSteps as string[]) || ["Registration", "Payment", "Review", "Approval", "Completed"];
      const application = await storage.createApplication({
        userId: targetUser.id,
        packageId,
        currentStep: 1,
        totalSteps: workflowSteps.length,
        status: "pending",
        formData: {
          manualPayment: true,
          manualPaymentReason: reason || "Manual payment by admin",
          manualPaymentBy: `${req.user!.firstName} ${req.user!.lastName}`,
          manualPaymentAt: new Date().toISOString(),
          fullName: `${targetUser.firstName} ${targetUser.lastName}`,
          firstName: targetUser.firstName,
          lastName: targetUser.lastName,
          email: targetUser.email,
          phone: targetUser.phone || "",
          dateOfBirth: targetUser.dateOfBirth || "",
          address: targetUser.address || "",
          city: targetUser.city || "",
          state: targetUser.state || "",
          zipCode: targetUser.zipCode || "",
        },
        paymentStatus: "paid",
        paymentAmount: pkg.price,
      });
      for (let i = 0; i < workflowSteps.length; i++) {
        await storage.createApplicationStep({
          applicationId: application.id,
          stepNumber: i + 1,
          name: workflowSteps[i],
          status: i === 0 ? "in-progress" : "pending",
        });
      }
      const adminSettings = await storage.getAdminSettings();
      const doctor = await storage.getNextDoctorForAssignment();
      if (doctor) {
        const doctorUser = await storage.getUser(doctor.userId || doctor.id);
        const protocol = process.env.NODE_ENV === "production" ? "https" : "https";
        const host = req.get("host") || "localhost:5000";
        const patientName = `${targetUser.firstName} ${targetUser.lastName}`;
        if (adminSettings?.autoCompleteApplications) {
          await storage.updateApplication(application.id, {
            status: "doctor_approved",
            assignedReviewerId: doctor.userId || doctor.id,
            level2ApprovedAt: new Date(),
            level2ApprovedBy: doctor.userId || doctor.id,
          });
          await autoGenerateDocument(application.id, doctor.userId || doctor.id);
          fireAutoMessageTriggers(application.id, "doctor_approved");
          const patientContactEmail = getContactEmail(targetUser);
          if (patientContactEmail) {
            const dashboardUrl = `${protocol}://${host}/dashboard/applicant/documents`;
            sendPatientApprovalEmail({
              patientEmail: patientContactEmail,
              patientName,
              packageName: pkg.name,
              applicationId: application.id,
              dashboardUrl,
            }).catch(err => console.error("Manual payment patient email error:", err));
          }
          if (doctorUser) {
            sendDoctorCompletionCopyEmail({
              doctorEmail: getContactEmail(doctorUser),
              doctorName: doctorUser.lastName || doctor.fullName || "Doctor",
              patientName,
              patientEmail: getContactEmail(targetUser),
              packageName: pkg.name,
              applicationId: application.id,
              formData: application.formData || {},
            }).catch(err => console.error("Manual payment doctor copy error:", err));
          }
          console.log(`Manual payment: Application ${application.id} auto-completed for ${patientName}`);
        } else {
          const token = randomBytes(32).toString("hex");
          const expiresAt = new Date();
          expiresAt.setDate(expiresAt.getDate() + 7);
          await storage.createDoctorReviewToken({
            applicationId: application.id,
            doctorId: doctor.userId || doctor.id,
            token,
            status: "pending",
            expiresAt,
          });
          await storage.updateApplication(application.id, {
            status: "doctor_review",
            assignedReviewerId: doctor.userId || doctor.id,
          });
          const reviewUrl = `${protocol}://${host}/review/${token}`;
          if (doctorUser) {
            sendDoctorApprovalEmail({
              doctorEmail: getContactEmail(doctorUser),
              doctorName: doctorUser.lastName || doctor.fullName || "Doctor",
              patientName,
              patientEmail: getContactEmail(targetUser),
              packageName: pkg.name,
              formData: application.formData || {},
              reviewUrl,
              applicationId: application.id,
            }).catch(err => console.error("Manual payment doctor email error:", err));
          }
          fireAutoMessageTriggers(application.id, "doctor_review");
          console.log(`Manual payment: Application ${application.id} sent to doctor for ${patientName}`);
        }
        const notificationEmail = adminSettings?.notificationEmail;
        if (notificationEmail) {
          sendAdminNotificationEmail({
            adminEmail: notificationEmail,
            doctorName: doctorUser?.lastName || doctor.fullName || "Doctor",
            patientName,
            patientEmail: getContactEmail(targetUser),
            packageName: pkg.name,
            formData: application.formData || {},
            reviewUrl: `${protocol}://${host}/dashboard/admin/applications`,
            applicationId: application.id,
          }).catch(err => console.error("Manual payment admin email error:", err));
        }
      }
      await storage.createActivityLog({
        userId: req.user!.id,
        action: "manual_payment",
        entityType: "application",
        entityId: application.id,
        details: {
          targetUserId: targetUser.id,
          packageId,
          reason: reason || "Manual payment by admin",
          packageName: pkg.name,
        },
      });
      res.json({ application, message: "Manual payment processed successfully" });
    } catch (error: any) {
      console.error("Manual payment error:", error);
      res.status(500).json({ message: error.message });
    }
  });
File 2: client/src/pages/dashboard/admin/UsersManagement.tsx — 4 Changes
2a. Add imports
Find the lucide-react import line:

import { Search, UserCog, Plus, Loader2, Stethoscope, FileText, Info } from "lucide-react";
Change to:

import { Label } from "@/components/ui/label";
import { Search, UserCog, Plus, Loader2, Stethoscope, FileText, Info, DollarSign } from "lucide-react";
2b. Add state variables
Find:

const [isAddDialogOpen, setIsAddDialogOpen] = useState(false);
const [showPlaceholders, setShowPlaceholders] = useState(false);
Change to:

const [isAddDialogOpen, setIsAddDialogOpen] = useState(false);
const [showPlaceholders, setShowPlaceholders] = useState(false);
const [manualPaymentUser, setManualPaymentUser] = useState<User | null>(null);
const [manualPaymentPackageId, setManualPaymentPackageId] = useState("");
const [manualPaymentReason, setManualPaymentReason] = useState("");
const [manualPaymentLoading, setManualPaymentLoading] = useState(false);
2c. Add packages query and handler function
Find handleOpenProfile and add the packages query and manual payment handler before it:

const { data: packages } = useQuery<any[]>({
    queryKey: ["/api/packages"],
  });
  const activePackages = packages?.filter((p: any) => p.isActive) || [];
  const handleOpenProfile = (user: User) => {
    setSelectedUser(user);
  };
  const handleManualPayment = async () => {
    if (!manualPaymentUser || !manualPaymentPackageId) return;
    setManualPaymentLoading(true);
    try {
      const res = await apiRequest("POST", `/api/admin/users/${manualPaymentUser.id}/manual-payment`, {
        packageId: manualPaymentPackageId,
        reason: manualPaymentReason || "Manual payment by admin",
      });
      const data = await res.json();
      toast({
        title: "Manual Payment Processed",
        description: `Application created for ${manualPaymentUser.firstName} ${manualPaymentUser.lastName}. ${data.message || ""}`,
      });
      setManualPaymentUser(null);
      setManualPaymentPackageId("");
      setManualPaymentReason("");
      queryClient.invalidateQueries({ queryKey: ["/api/admin/users"] });
    } catch (error: any) {
      toast({
        title: "Payment Failed",
        description: error.message || "Something went wrong",
        variant: "destructive",
      });
    } finally {
      setManualPaymentLoading(false);
    }
  };
2d. Replace the Actions table cell
Find the Actions <TableCell> in the user row — the one with the UserCog profile button:

Old:

<TableCell className="text-right">
  <Button
    variant="ghost"
    size="sm"
    onClick={() => handleOpenProfile(user)}
    data-testid={`button-view-profile-${user.id}`}
  >
    <UserCog className="h-4 w-4" />
  </Button>
</TableCell>
New:

<TableCell className="text-right">
  <div className="flex items-center justify-end gap-1">
    {user.userLevel === 1 && (
      <Button
        variant="ghost"
        size="sm"
        onClick={() => {
          setManualPaymentUser(user);
          setManualPaymentPackageId("");
          setManualPaymentReason("");
        }}
        data-testid={`button-manual-payment-${user.id}`}
        title="Manual Payment"
      >
        <DollarSign className="h-4 w-4 text-green-500" />
      </Button>
    )}
    <Button
      variant="ghost"
      size="sm"
      onClick={() => handleOpenProfile(user)}
      data-testid={`button-view-profile-${user.id}`}
    >
      <UserCog className="h-4 w-4" />
    </Button>
  </div>
</TableCell>
2e. Add the Manual Payment dialog
Add this dialog after the <UserProfileModal> component and before the closing </div> and </DashboardLayout>:

<Dialog open={!!manualPaymentUser} onOpenChange={(open) => { if (!open) setManualPaymentUser(null); }}>
  <DialogContent>
    <DialogHeader>
      <DialogTitle className="flex items-center gap-2">
        <DollarSign className="h-5 w-5 text-green-500" />
        Manual Payment
      </DialogTitle>
      <DialogDescription>
        Process a manual payment for {manualPaymentUser?.firstName} {manualPaymentUser?.lastName}. This will create an application and run it through the full workflow as if the patient paid on their own.
      </DialogDescription>
    </DialogHeader>
    <div className="space-y-4 py-2">
      <div className="space-y-2">
        <Label>Select Package</Label>
        <Select value={manualPaymentPackageId} onValueChange={setManualPaymentPackageId}>
          <SelectTrigger data-testid="select-manual-payment-package">
            <SelectValue placeholder="Choose a registration type..." />
          </SelectTrigger>
          <SelectContent>
            {activePackages.map((pkg: any) => (
              <SelectItem key={pkg.id} value={pkg.id} data-testid={`select-package-${pkg.id}`}>
                {pkg.name} — ${(Number(pkg.price) / 100).toFixed(2)}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>
      <div className="space-y-2">
        <Label>Reason for Manual Payment</Label>
        <Textarea
          placeholder="e.g. Phone payment, cash payment, courtesy waiver..."
          value={manualPaymentReason}
          onChange={(e) => setManualPaymentReason(e.target.value)}
          rows={3}
          data-testid="input-manual-payment-reason"
        />
      </div>
    </div>
    <div className="flex justify-end gap-2 pt-2">
      <Button
        variant="outline"
        onClick={() => setManualPaymentUser(null)}
        disabled={manualPaymentLoading}
        data-testid="button-cancel-manual-payment"
      >
        Cancel
      </Button>
      <Button
        onClick={handleManualPayment}
        disabled={!manualPaymentPackageId || manualPaymentLoading}
        data-testid="button-confirm-manual-payment"
      >
        {manualPaymentLoading ? (
          <>
            <Loader2 className="h-4 w-4 mr-2 animate-spin" />
            Processing...
          </>
        ) : (
          "Process Payment"
        )}
      </Button>
    </div>
  </DialogContent>
</Dialog>
File 3: client/src/components/shared/UserProfileModal.tsx — Cleanup (optional)
If you previously added manual payment state in this file (from partial work), remove these lines if present:

const [showManualPayment, setShowManualPayment] = useState(false);
const [manualPaymentPackageId, setManualPaymentPackageId] = useState("");
const [manualPaymentReason, setManualPaymentReason] = useState("");
const [manualPaymentLoading, setManualPaymentLoading] = useState(false);
These are not used — the feature lives entirely in UsersManagement.tsx.

That's the complete manual payment feature. The green $ button only appears for Applicant-level users (userLevel === 1), the dialog lets you pick a package and type a reason, and on confirm it runs the entire pipeline — auto-complete or doctor review, all emails, activity log — exactly as if the patient paid themselves.